/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "client_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTSProtocolVersionValues[] = {
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V1,
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V2,
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V3
};
const char* _kTSProtocolVersionNames[] = {
  "IOTDB_SERVICE_PROTOCOL_V1",
  "IOTDB_SERVICE_PROTOCOL_V2",
  "IOTDB_SERVICE_PROTOCOL_V3"
};
const std::map<int, const char*> _TSProtocolVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTSProtocolVersionValues, _kTSProtocolVersionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TSProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TSProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TSProtocolVersion_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TSProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TSProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TSProtocolVersion_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTSConnectionTypeValues[] = {
  TSConnectionType::THRIFT_BASED,
  TSConnectionType::MQTT_BASED,
  TSConnectionType::INTERNAL,
  TSConnectionType::REST_BASED
};
const char* _kTSConnectionTypeNames[] = {
  "THRIFT_BASED",
  "MQTT_BASED",
  "INTERNAL",
  "REST_BASED"
};
const std::map<int, const char*> _TSConnectionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTSConnectionTypeValues, _kTSConnectionTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TSConnectionType::type& val) {
  std::map<int, const char*>::const_iterator it = _TSConnectionType_VALUES_TO_NAMES.find(val);
  if (it != _TSConnectionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TSConnectionType::type& val) {
  std::map<int, const char*>::const_iterator it = _TSConnectionType_VALUES_TO_NAMES.find(val);
  if (it != _TSConnectionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TSQueryDataSet::~TSQueryDataSet() noexcept {
}


void TSQueryDataSet::__set_time(const std::string& val) {
  this->time = val;
}

void TSQueryDataSet::__set_valueList(const std::vector<std::string> & val) {
  this->valueList = val;
}

void TSQueryDataSet::__set_bitmapList(const std::vector<std::string> & val) {
  this->bitmapList = val;
}
std::ostream& operator<<(std::ostream& out, const TSQueryDataSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryDataSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_time = false;
  bool isset_valueList = false;
  bool isset_bitmapList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->time);
          isset_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueList.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->valueList.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readBinary(this->valueList[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bitmapList.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->bitmapList.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readBinary(this->bitmapList[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_bitmapList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bitmapList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryDataSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryDataSet");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valueList.size()));
    std::vector<std::string> ::const_iterator _iter10;
    for (_iter10 = this->valueList.begin(); _iter10 != this->valueList.end(); ++_iter10)
    {
      xfer += oprot->writeBinary((*_iter10));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bitmapList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bitmapList.size()));
    std::vector<std::string> ::const_iterator _iter11;
    for (_iter11 = this->bitmapList.begin(); _iter11 != this->bitmapList.end(); ++_iter11)
    {
      xfer += oprot->writeBinary((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryDataSet &a, TSQueryDataSet &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.valueList, b.valueList);
  swap(a.bitmapList, b.bitmapList);
}

TSQueryDataSet::TSQueryDataSet(const TSQueryDataSet& other12) {
  time = other12.time;
  valueList = other12.valueList;
  bitmapList = other12.bitmapList;
}
TSQueryDataSet& TSQueryDataSet::operator=(const TSQueryDataSet& other13) {
  time = other13.time;
  valueList = other13.valueList;
  bitmapList = other13.bitmapList;
  return *this;
}
void TSQueryDataSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryDataSet(";
  out << "time=" << to_string(time);
  out << ", " << "valueList=" << to_string(valueList);
  out << ", " << "bitmapList=" << to_string(bitmapList);
  out << ")";
}


TSQueryNonAlignDataSet::~TSQueryNonAlignDataSet() noexcept {
}


void TSQueryNonAlignDataSet::__set_timeList(const std::vector<std::string> & val) {
  this->timeList = val;
}

void TSQueryNonAlignDataSet::__set_valueList(const std::vector<std::string> & val) {
  this->valueList = val;
}
std::ostream& operator<<(std::ostream& out, const TSQueryNonAlignDataSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryNonAlignDataSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timeList = false;
  bool isset_valueList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timeList.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->timeList.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readBinary(this->timeList[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueList.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->valueList.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readBinary(this->valueList[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryNonAlignDataSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryNonAlignDataSet");

  xfer += oprot->writeFieldBegin("timeList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->timeList.size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = this->timeList.begin(); _iter24 != this->timeList.end(); ++_iter24)
    {
      xfer += oprot->writeBinary((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valueList.size()));
    std::vector<std::string> ::const_iterator _iter25;
    for (_iter25 = this->valueList.begin(); _iter25 != this->valueList.end(); ++_iter25)
    {
      xfer += oprot->writeBinary((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryNonAlignDataSet &a, TSQueryNonAlignDataSet &b) {
  using ::std::swap;
  swap(a.timeList, b.timeList);
  swap(a.valueList, b.valueList);
}

TSQueryNonAlignDataSet::TSQueryNonAlignDataSet(const TSQueryNonAlignDataSet& other26) {
  timeList = other26.timeList;
  valueList = other26.valueList;
}
TSQueryNonAlignDataSet& TSQueryNonAlignDataSet::operator=(const TSQueryNonAlignDataSet& other27) {
  timeList = other27.timeList;
  valueList = other27.valueList;
  return *this;
}
void TSQueryNonAlignDataSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryNonAlignDataSet(";
  out << "timeList=" << to_string(timeList);
  out << ", " << "valueList=" << to_string(valueList);
  out << ")";
}


TSTracingInfo::~TSTracingInfo() noexcept {
}


void TSTracingInfo::__set_activityList(const std::vector<std::string> & val) {
  this->activityList = val;
}

void TSTracingInfo::__set_elapsedTimeList(const std::vector<int64_t> & val) {
  this->elapsedTimeList = val;
}

void TSTracingInfo::__set_seriesPathNum(const int32_t val) {
  this->seriesPathNum = val;
__isset.seriesPathNum = true;
}

void TSTracingInfo::__set_seqFileNum(const int32_t val) {
  this->seqFileNum = val;
__isset.seqFileNum = true;
}

void TSTracingInfo::__set_unSeqFileNum(const int32_t val) {
  this->unSeqFileNum = val;
__isset.unSeqFileNum = true;
}

void TSTracingInfo::__set_sequenceChunkNum(const int32_t val) {
  this->sequenceChunkNum = val;
__isset.sequenceChunkNum = true;
}

void TSTracingInfo::__set_sequenceChunkPointNum(const int64_t val) {
  this->sequenceChunkPointNum = val;
__isset.sequenceChunkPointNum = true;
}

void TSTracingInfo::__set_unsequenceChunkNum(const int32_t val) {
  this->unsequenceChunkNum = val;
__isset.unsequenceChunkNum = true;
}

void TSTracingInfo::__set_unsequenceChunkPointNum(const int64_t val) {
  this->unsequenceChunkPointNum = val;
__isset.unsequenceChunkPointNum = true;
}

void TSTracingInfo::__set_totalPageNum(const int32_t val) {
  this->totalPageNum = val;
__isset.totalPageNum = true;
}

void TSTracingInfo::__set_overlappedPageNum(const int32_t val) {
  this->overlappedPageNum = val;
__isset.overlappedPageNum = true;
}
std::ostream& operator<<(std::ostream& out, const TSTracingInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSTracingInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_activityList = false;
  bool isset_elapsedTimeList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->activityList.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->activityList.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->activityList[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          isset_activityList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elapsedTimeList.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->elapsedTimeList.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readI64(this->elapsedTimeList[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          isset_elapsedTimeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->seriesPathNum);
          this->__isset.seriesPathNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->seqFileNum);
          this->__isset.seqFileNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->unSeqFileNum);
          this->__isset.unSeqFileNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sequenceChunkNum);
          this->__isset.sequenceChunkNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sequenceChunkPointNum);
          this->__isset.sequenceChunkPointNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->unsequenceChunkNum);
          this->__isset.unsequenceChunkNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unsequenceChunkPointNum);
          this->__isset.unsequenceChunkPointNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalPageNum);
          this->__isset.totalPageNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->overlappedPageNum);
          this->__isset.overlappedPageNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_activityList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_elapsedTimeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSTracingInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSTracingInfo");

  xfer += oprot->writeFieldBegin("activityList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->activityList.size()));
    std::vector<std::string> ::const_iterator _iter38;
    for (_iter38 = this->activityList.begin(); _iter38 != this->activityList.end(); ++_iter38)
    {
      xfer += oprot->writeString((*_iter38));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("elapsedTimeList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->elapsedTimeList.size()));
    std::vector<int64_t> ::const_iterator _iter39;
    for (_iter39 = this->elapsedTimeList.begin(); _iter39 != this->elapsedTimeList.end(); ++_iter39)
    {
      xfer += oprot->writeI64((*_iter39));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.seriesPathNum) {
    xfer += oprot->writeFieldBegin("seriesPathNum", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->seriesPathNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.seqFileNum) {
    xfer += oprot->writeFieldBegin("seqFileNum", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->seqFileNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unSeqFileNum) {
    xfer += oprot->writeFieldBegin("unSeqFileNum", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->unSeqFileNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sequenceChunkNum) {
    xfer += oprot->writeFieldBegin("sequenceChunkNum", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->sequenceChunkNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sequenceChunkPointNum) {
    xfer += oprot->writeFieldBegin("sequenceChunkPointNum", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->sequenceChunkPointNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unsequenceChunkNum) {
    xfer += oprot->writeFieldBegin("unsequenceChunkNum", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->unsequenceChunkNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unsequenceChunkPointNum) {
    xfer += oprot->writeFieldBegin("unsequenceChunkPointNum", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->unsequenceChunkPointNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.totalPageNum) {
    xfer += oprot->writeFieldBegin("totalPageNum", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->totalPageNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.overlappedPageNum) {
    xfer += oprot->writeFieldBegin("overlappedPageNum", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->overlappedPageNum);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSTracingInfo &a, TSTracingInfo &b) {
  using ::std::swap;
  swap(a.activityList, b.activityList);
  swap(a.elapsedTimeList, b.elapsedTimeList);
  swap(a.seriesPathNum, b.seriesPathNum);
  swap(a.seqFileNum, b.seqFileNum);
  swap(a.unSeqFileNum, b.unSeqFileNum);
  swap(a.sequenceChunkNum, b.sequenceChunkNum);
  swap(a.sequenceChunkPointNum, b.sequenceChunkPointNum);
  swap(a.unsequenceChunkNum, b.unsequenceChunkNum);
  swap(a.unsequenceChunkPointNum, b.unsequenceChunkPointNum);
  swap(a.totalPageNum, b.totalPageNum);
  swap(a.overlappedPageNum, b.overlappedPageNum);
  swap(a.__isset, b.__isset);
}

TSTracingInfo::TSTracingInfo(const TSTracingInfo& other40) {
  activityList = other40.activityList;
  elapsedTimeList = other40.elapsedTimeList;
  seriesPathNum = other40.seriesPathNum;
  seqFileNum = other40.seqFileNum;
  unSeqFileNum = other40.unSeqFileNum;
  sequenceChunkNum = other40.sequenceChunkNum;
  sequenceChunkPointNum = other40.sequenceChunkPointNum;
  unsequenceChunkNum = other40.unsequenceChunkNum;
  unsequenceChunkPointNum = other40.unsequenceChunkPointNum;
  totalPageNum = other40.totalPageNum;
  overlappedPageNum = other40.overlappedPageNum;
  __isset = other40.__isset;
}
TSTracingInfo& TSTracingInfo::operator=(const TSTracingInfo& other41) {
  activityList = other41.activityList;
  elapsedTimeList = other41.elapsedTimeList;
  seriesPathNum = other41.seriesPathNum;
  seqFileNum = other41.seqFileNum;
  unSeqFileNum = other41.unSeqFileNum;
  sequenceChunkNum = other41.sequenceChunkNum;
  sequenceChunkPointNum = other41.sequenceChunkPointNum;
  unsequenceChunkNum = other41.unsequenceChunkNum;
  unsequenceChunkPointNum = other41.unsequenceChunkPointNum;
  totalPageNum = other41.totalPageNum;
  overlappedPageNum = other41.overlappedPageNum;
  __isset = other41.__isset;
  return *this;
}
void TSTracingInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSTracingInfo(";
  out << "activityList=" << to_string(activityList);
  out << ", " << "elapsedTimeList=" << to_string(elapsedTimeList);
  out << ", " << "seriesPathNum="; (__isset.seriesPathNum ? (out << to_string(seriesPathNum)) : (out << "<null>"));
  out << ", " << "seqFileNum="; (__isset.seqFileNum ? (out << to_string(seqFileNum)) : (out << "<null>"));
  out << ", " << "unSeqFileNum="; (__isset.unSeqFileNum ? (out << to_string(unSeqFileNum)) : (out << "<null>"));
  out << ", " << "sequenceChunkNum="; (__isset.sequenceChunkNum ? (out << to_string(sequenceChunkNum)) : (out << "<null>"));
  out << ", " << "sequenceChunkPointNum="; (__isset.sequenceChunkPointNum ? (out << to_string(sequenceChunkPointNum)) : (out << "<null>"));
  out << ", " << "unsequenceChunkNum="; (__isset.unsequenceChunkNum ? (out << to_string(unsequenceChunkNum)) : (out << "<null>"));
  out << ", " << "unsequenceChunkPointNum="; (__isset.unsequenceChunkPointNum ? (out << to_string(unsequenceChunkPointNum)) : (out << "<null>"));
  out << ", " << "totalPageNum="; (__isset.totalPageNum ? (out << to_string(totalPageNum)) : (out << "<null>"));
  out << ", " << "overlappedPageNum="; (__isset.overlappedPageNum ? (out << to_string(overlappedPageNum)) : (out << "<null>"));
  out << ")";
}


TSExecuteStatementResp::~TSExecuteStatementResp() noexcept {
}


void TSExecuteStatementResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSExecuteStatementResp::__set_queryId(const int64_t val) {
  this->queryId = val;
__isset.queryId = true;
}

void TSExecuteStatementResp::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
__isset.columns = true;
}

void TSExecuteStatementResp::__set_operationType(const std::string& val) {
  this->operationType = val;
__isset.operationType = true;
}

void TSExecuteStatementResp::__set_ignoreTimeStamp(const bool val) {
  this->ignoreTimeStamp = val;
__isset.ignoreTimeStamp = true;
}

void TSExecuteStatementResp::__set_dataTypeList(const std::vector<std::string> & val) {
  this->dataTypeList = val;
__isset.dataTypeList = true;
}

void TSExecuteStatementResp::__set_queryDataSet(const TSQueryDataSet& val) {
  this->queryDataSet = val;
__isset.queryDataSet = true;
}

void TSExecuteStatementResp::__set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val) {
  this->nonAlignQueryDataSet = val;
__isset.nonAlignQueryDataSet = true;
}

void TSExecuteStatementResp::__set_columnNameIndexMap(const std::map<std::string, int32_t> & val) {
  this->columnNameIndexMap = val;
__isset.columnNameIndexMap = true;
}

void TSExecuteStatementResp::__set_sgColumns(const std::vector<std::string> & val) {
  this->sgColumns = val;
__isset.sgColumns = true;
}

void TSExecuteStatementResp::__set_aliasColumns(const std::vector<int8_t> & val) {
  this->aliasColumns = val;
__isset.aliasColumns = true;
}

void TSExecuteStatementResp::__set_tracingInfo(const TSTracingInfo& val) {
  this->tracingInfo = val;
__isset.tracingInfo = true;
}

void TSExecuteStatementResp::__set_queryResult(const std::vector<std::string> & val) {
  this->queryResult = val;
__isset.queryResult = true;
}

void TSExecuteStatementResp::__set_moreData(const bool val) {
  this->moreData = val;
__isset.moreData = true;
}

void TSExecuteStatementResp::__set_database(const std::string& val) {
  this->database = val;
__isset.database = true;
}

void TSExecuteStatementResp::__set_tableModel(const bool val) {
  this->tableModel = val;
__isset.tableModel = true;
}

void TSExecuteStatementResp::__set_columnIndex2TsBlockColumnIndexList(const std::vector<int32_t> & val) {
  this->columnIndex2TsBlockColumnIndexList = val;
__isset.columnIndex2TsBlockColumnIndexList = true;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteStatementResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->columns.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readString(this->columns[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operationType);
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreTimeStamp);
          this->__isset.ignoreTimeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypeList.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->dataTypeList.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readString(this->dataTypeList[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataTypeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryDataSet.read(iprot);
          this->__isset.queryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nonAlignQueryDataSet.read(iprot);
          this->__isset.nonAlignQueryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->columnNameIndexMap.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _ktype53;
            ::apache::thrift::protocol::TType _vtype54;
            xfer += iprot->readMapBegin(_ktype53, _vtype54, _size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              std::string _key57;
              xfer += iprot->readString(_key57);
              int32_t& _val58 = this->columnNameIndexMap[_key57];
              xfer += iprot->readI32(_val58);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.columnNameIndexMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sgColumns.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->sgColumns.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += iprot->readString(this->sgColumns[_i63]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sgColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aliasColumns.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->aliasColumns.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += iprot->readByte(this->aliasColumns[_i68]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aliasColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tracingInfo.read(iprot);
          this->__isset.tracingInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->queryResult.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->queryResult.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += iprot->readBinary(this->queryResult[_i73]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.queryResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->moreData);
          this->__isset.moreData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          this->__isset.database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->tableModel);
          this->__isset.tableModel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnIndex2TsBlockColumnIndexList.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->columnIndex2TsBlockColumnIndexList.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += iprot->readI32(this->columnIndex2TsBlockColumnIndexList[_i78]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnIndex2TsBlockColumnIndexList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteStatementResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryId) {
    xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->queryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter79;
      for (_iter79 = this->columns.begin(); _iter79 != this->columns.end(); ++_iter79)
      {
        xfer += oprot->writeString((*_iter79));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreTimeStamp) {
    xfer += oprot->writeFieldBegin("ignoreTimeStamp", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ignoreTimeStamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataTypeList) {
    xfer += oprot->writeFieldBegin("dataTypeList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dataTypeList.size()));
      std::vector<std::string> ::const_iterator _iter80;
      for (_iter80 = this->dataTypeList.begin(); _iter80 != this->dataTypeList.end(); ++_iter80)
      {
        xfer += oprot->writeString((*_iter80));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryDataSet) {
    xfer += oprot->writeFieldBegin("queryDataSet", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->queryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nonAlignQueryDataSet) {
    xfer += oprot->writeFieldBegin("nonAlignQueryDataSet", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->nonAlignQueryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnNameIndexMap) {
    xfer += oprot->writeFieldBegin("columnNameIndexMap", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->columnNameIndexMap.size()));
      std::map<std::string, int32_t> ::const_iterator _iter81;
      for (_iter81 = this->columnNameIndexMap.begin(); _iter81 != this->columnNameIndexMap.end(); ++_iter81)
      {
        xfer += oprot->writeString(_iter81->first);
        xfer += oprot->writeI32(_iter81->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sgColumns) {
    xfer += oprot->writeFieldBegin("sgColumns", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sgColumns.size()));
      std::vector<std::string> ::const_iterator _iter82;
      for (_iter82 = this->sgColumns.begin(); _iter82 != this->sgColumns.end(); ++_iter82)
      {
        xfer += oprot->writeString((*_iter82));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aliasColumns) {
    xfer += oprot->writeFieldBegin("aliasColumns", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->aliasColumns.size()));
      std::vector<int8_t> ::const_iterator _iter83;
      for (_iter83 = this->aliasColumns.begin(); _iter83 != this->aliasColumns.end(); ++_iter83)
      {
        xfer += oprot->writeByte((*_iter83));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracingInfo) {
    xfer += oprot->writeFieldBegin("tracingInfo", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->tracingInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryResult) {
    xfer += oprot->writeFieldBegin("queryResult", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->queryResult.size()));
      std::vector<std::string> ::const_iterator _iter84;
      for (_iter84 = this->queryResult.begin(); _iter84 != this->queryResult.end(); ++_iter84)
      {
        xfer += oprot->writeBinary((*_iter84));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.moreData) {
    xfer += oprot->writeFieldBegin("moreData", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->moreData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.database) {
    xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->database);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableModel) {
    xfer += oprot->writeFieldBegin("tableModel", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->tableModel);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnIndex2TsBlockColumnIndexList) {
    xfer += oprot->writeFieldBegin("columnIndex2TsBlockColumnIndexList", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->columnIndex2TsBlockColumnIndexList.size()));
      std::vector<int32_t> ::const_iterator _iter85;
      for (_iter85 = this->columnIndex2TsBlockColumnIndexList.begin(); _iter85 != this->columnIndex2TsBlockColumnIndexList.end(); ++_iter85)
      {
        xfer += oprot->writeI32((*_iter85));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteStatementResp &a, TSExecuteStatementResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.queryId, b.queryId);
  swap(a.columns, b.columns);
  swap(a.operationType, b.operationType);
  swap(a.ignoreTimeStamp, b.ignoreTimeStamp);
  swap(a.dataTypeList, b.dataTypeList);
  swap(a.queryDataSet, b.queryDataSet);
  swap(a.nonAlignQueryDataSet, b.nonAlignQueryDataSet);
  swap(a.columnNameIndexMap, b.columnNameIndexMap);
  swap(a.sgColumns, b.sgColumns);
  swap(a.aliasColumns, b.aliasColumns);
  swap(a.tracingInfo, b.tracingInfo);
  swap(a.queryResult, b.queryResult);
  swap(a.moreData, b.moreData);
  swap(a.database, b.database);
  swap(a.tableModel, b.tableModel);
  swap(a.columnIndex2TsBlockColumnIndexList, b.columnIndex2TsBlockColumnIndexList);
  swap(a.__isset, b.__isset);
}

TSExecuteStatementResp::TSExecuteStatementResp(const TSExecuteStatementResp& other86) {
  status = other86.status;
  queryId = other86.queryId;
  columns = other86.columns;
  operationType = other86.operationType;
  ignoreTimeStamp = other86.ignoreTimeStamp;
  dataTypeList = other86.dataTypeList;
  queryDataSet = other86.queryDataSet;
  nonAlignQueryDataSet = other86.nonAlignQueryDataSet;
  columnNameIndexMap = other86.columnNameIndexMap;
  sgColumns = other86.sgColumns;
  aliasColumns = other86.aliasColumns;
  tracingInfo = other86.tracingInfo;
  queryResult = other86.queryResult;
  moreData = other86.moreData;
  database = other86.database;
  tableModel = other86.tableModel;
  columnIndex2TsBlockColumnIndexList = other86.columnIndex2TsBlockColumnIndexList;
  __isset = other86.__isset;
}
TSExecuteStatementResp& TSExecuteStatementResp::operator=(const TSExecuteStatementResp& other87) {
  status = other87.status;
  queryId = other87.queryId;
  columns = other87.columns;
  operationType = other87.operationType;
  ignoreTimeStamp = other87.ignoreTimeStamp;
  dataTypeList = other87.dataTypeList;
  queryDataSet = other87.queryDataSet;
  nonAlignQueryDataSet = other87.nonAlignQueryDataSet;
  columnNameIndexMap = other87.columnNameIndexMap;
  sgColumns = other87.sgColumns;
  aliasColumns = other87.aliasColumns;
  tracingInfo = other87.tracingInfo;
  queryResult = other87.queryResult;
  moreData = other87.moreData;
  database = other87.database;
  tableModel = other87.tableModel;
  columnIndex2TsBlockColumnIndexList = other87.columnIndex2TsBlockColumnIndexList;
  __isset = other87.__isset;
  return *this;
}
void TSExecuteStatementResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteStatementResp(";
  out << "status=" << to_string(status);
  out << ", " << "queryId="; (__isset.queryId ? (out << to_string(queryId)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ", " << "ignoreTimeStamp="; (__isset.ignoreTimeStamp ? (out << to_string(ignoreTimeStamp)) : (out << "<null>"));
  out << ", " << "dataTypeList="; (__isset.dataTypeList ? (out << to_string(dataTypeList)) : (out << "<null>"));
  out << ", " << "queryDataSet="; (__isset.queryDataSet ? (out << to_string(queryDataSet)) : (out << "<null>"));
  out << ", " << "nonAlignQueryDataSet="; (__isset.nonAlignQueryDataSet ? (out << to_string(nonAlignQueryDataSet)) : (out << "<null>"));
  out << ", " << "columnNameIndexMap="; (__isset.columnNameIndexMap ? (out << to_string(columnNameIndexMap)) : (out << "<null>"));
  out << ", " << "sgColumns="; (__isset.sgColumns ? (out << to_string(sgColumns)) : (out << "<null>"));
  out << ", " << "aliasColumns="; (__isset.aliasColumns ? (out << to_string(aliasColumns)) : (out << "<null>"));
  out << ", " << "tracingInfo="; (__isset.tracingInfo ? (out << to_string(tracingInfo)) : (out << "<null>"));
  out << ", " << "queryResult="; (__isset.queryResult ? (out << to_string(queryResult)) : (out << "<null>"));
  out << ", " << "moreData="; (__isset.moreData ? (out << to_string(moreData)) : (out << "<null>"));
  out << ", " << "database="; (__isset.database ? (out << to_string(database)) : (out << "<null>"));
  out << ", " << "tableModel="; (__isset.tableModel ? (out << to_string(tableModel)) : (out << "<null>"));
  out << ", " << "columnIndex2TsBlockColumnIndexList="; (__isset.columnIndex2TsBlockColumnIndexList ? (out << to_string(columnIndex2TsBlockColumnIndexList)) : (out << "<null>"));
  out << ")";
}


TSOpenSessionResp::~TSOpenSessionResp() noexcept {
}


void TSOpenSessionResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSOpenSessionResp::__set_serverProtocolVersion(const TSProtocolVersion::type val) {
  this->serverProtocolVersion = val;
}

void TSOpenSessionResp::__set_sessionId(const int64_t val) {
  this->sessionId = val;
__isset.sessionId = true;
}

void TSOpenSessionResp::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSOpenSessionResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSOpenSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_serverProtocolVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast88;
          xfer += iprot->readI32(ecast88);
          this->serverProtocolVersion = (TSProtocolVersion::type)ecast88;
          isset_serverProtocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _ktype90;
            ::apache::thrift::protocol::TType _vtype91;
            xfer += iprot->readMapBegin(_ktype90, _vtype91, _size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              std::string _key94;
              xfer += iprot->readString(_key94);
              std::string& _val95 = this->configuration[_key94];
              xfer += iprot->readString(_val95);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverProtocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSOpenSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSOpenSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverProtocolVersion", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->serverProtocolVersion);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sessionId) {
    xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->sessionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter96;
      for (_iter96 = this->configuration.begin(); _iter96 != this->configuration.end(); ++_iter96)
      {
        xfer += oprot->writeString(_iter96->first);
        xfer += oprot->writeString(_iter96->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSOpenSessionResp &a, TSOpenSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.serverProtocolVersion, b.serverProtocolVersion);
  swap(a.sessionId, b.sessionId);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSOpenSessionResp::TSOpenSessionResp(const TSOpenSessionResp& other97) {
  status = other97.status;
  serverProtocolVersion = other97.serverProtocolVersion;
  sessionId = other97.sessionId;
  configuration = other97.configuration;
  __isset = other97.__isset;
}
TSOpenSessionResp& TSOpenSessionResp::operator=(const TSOpenSessionResp& other98) {
  status = other98.status;
  serverProtocolVersion = other98.serverProtocolVersion;
  sessionId = other98.sessionId;
  configuration = other98.configuration;
  __isset = other98.__isset;
  return *this;
}
void TSOpenSessionResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSOpenSessionResp(";
  out << "status=" << to_string(status);
  out << ", " << "serverProtocolVersion=" << to_string(serverProtocolVersion);
  out << ", " << "sessionId="; (__isset.sessionId ? (out << to_string(sessionId)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSOpenSessionReq::~TSOpenSessionReq() noexcept {
}


void TSOpenSessionReq::__set_client_protocol(const TSProtocolVersion::type val) {
  this->client_protocol = val;
}

void TSOpenSessionReq::__set_zoneId(const std::string& val) {
  this->zoneId = val;
}

void TSOpenSessionReq::__set_username(const std::string& val) {
  this->username = val;
}

void TSOpenSessionReq::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void TSOpenSessionReq::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSOpenSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSOpenSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_client_protocol = false;
  bool isset_zoneId = false;
  bool isset_username = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->client_protocol = (TSProtocolVersion::type)ecast99;
          isset_client_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneId);
          isset_zoneId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          isset_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _ktype101;
            ::apache::thrift::protocol::TType _vtype102;
            xfer += iprot->readMapBegin(_ktype101, _vtype102, _size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              std::string _key105;
              xfer += iprot->readString(_key105);
              std::string& _val106 = this->configuration[_key105];
              xfer += iprot->readString(_val106);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_client_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_zoneId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_username)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSOpenSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSOpenSessionReq");

  xfer += oprot->writeFieldBegin("client_protocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->client_protocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zoneId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zoneId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter107;
      for (_iter107 = this->configuration.begin(); _iter107 != this->configuration.end(); ++_iter107)
      {
        xfer += oprot->writeString(_iter107->first);
        xfer += oprot->writeString(_iter107->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSOpenSessionReq &a, TSOpenSessionReq &b) {
  using ::std::swap;
  swap(a.client_protocol, b.client_protocol);
  swap(a.zoneId, b.zoneId);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSOpenSessionReq::TSOpenSessionReq(const TSOpenSessionReq& other108) {
  client_protocol = other108.client_protocol;
  zoneId = other108.zoneId;
  username = other108.username;
  password = other108.password;
  configuration = other108.configuration;
  __isset = other108.__isset;
}
TSOpenSessionReq& TSOpenSessionReq::operator=(const TSOpenSessionReq& other109) {
  client_protocol = other109.client_protocol;
  zoneId = other109.zoneId;
  username = other109.username;
  password = other109.password;
  configuration = other109.configuration;
  __isset = other109.__isset;
  return *this;
}
void TSOpenSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSOpenSessionReq(";
  out << "client_protocol=" << to_string(client_protocol);
  out << ", " << "zoneId=" << to_string(zoneId);
  out << ", " << "username=" << to_string(username);
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSCloseSessionReq::~TSCloseSessionReq() noexcept {
}


void TSCloseSessionReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}
std::ostream& operator<<(std::ostream& out, const TSCloseSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCloseSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCloseSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCloseSessionReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCloseSessionReq &a, TSCloseSessionReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
}

TSCloseSessionReq::TSCloseSessionReq(const TSCloseSessionReq& other110) {
  sessionId = other110.sessionId;
}
TSCloseSessionReq& TSCloseSessionReq::operator=(const TSCloseSessionReq& other111) {
  sessionId = other111.sessionId;
  return *this;
}
void TSCloseSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCloseSessionReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ")";
}


TSExecuteStatementReq::~TSExecuteStatementReq() noexcept {
}


void TSExecuteStatementReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSExecuteStatementReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TSExecuteStatementReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSExecuteStatementReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSExecuteStatementReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSExecuteStatementReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}

void TSExecuteStatementReq::__set_jdbcQuery(const bool val) {
  this->jdbcQuery = val;
__isset.jdbcQuery = true;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statement = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->jdbcQuery);
          this->__isset.jdbcQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteStatementReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jdbcQuery) {
    xfer += oprot->writeFieldBegin("jdbcQuery", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->jdbcQuery);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteStatementReq &a, TSExecuteStatementReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statement, b.statement);
  swap(a.statementId, b.statementId);
  swap(a.fetchSize, b.fetchSize);
  swap(a.timeout, b.timeout);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.jdbcQuery, b.jdbcQuery);
  swap(a.__isset, b.__isset);
}

TSExecuteStatementReq::TSExecuteStatementReq(const TSExecuteStatementReq& other112) {
  sessionId = other112.sessionId;
  statement = other112.statement;
  statementId = other112.statementId;
  fetchSize = other112.fetchSize;
  timeout = other112.timeout;
  enableRedirectQuery = other112.enableRedirectQuery;
  jdbcQuery = other112.jdbcQuery;
  __isset = other112.__isset;
}
TSExecuteStatementReq& TSExecuteStatementReq::operator=(const TSExecuteStatementReq& other113) {
  sessionId = other113.sessionId;
  statement = other113.statement;
  statementId = other113.statementId;
  fetchSize = other113.fetchSize;
  timeout = other113.timeout;
  enableRedirectQuery = other113.enableRedirectQuery;
  jdbcQuery = other113.jdbcQuery;
  __isset = other113.__isset;
  return *this;
}
void TSExecuteStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteStatementReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ", " << "jdbcQuery="; (__isset.jdbcQuery ? (out << to_string(jdbcQuery)) : (out << "<null>"));
  out << ")";
}


TSExecuteBatchStatementReq::~TSExecuteBatchStatementReq() noexcept {
}


void TSExecuteBatchStatementReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSExecuteBatchStatementReq::__set_statements(const std::vector<std::string> & val) {
  this->statements = val;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteBatchStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteBatchStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statements = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statements.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->statements.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += iprot->readString(this->statements[_i118]);
            }
            xfer += iprot->readListEnd();
          }
          isset_statements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteBatchStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteBatchStatementReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statements", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->statements.size()));
    std::vector<std::string> ::const_iterator _iter119;
    for (_iter119 = this->statements.begin(); _iter119 != this->statements.end(); ++_iter119)
    {
      xfer += oprot->writeString((*_iter119));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteBatchStatementReq &a, TSExecuteBatchStatementReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statements, b.statements);
}

TSExecuteBatchStatementReq::TSExecuteBatchStatementReq(const TSExecuteBatchStatementReq& other120) {
  sessionId = other120.sessionId;
  statements = other120.statements;
}
TSExecuteBatchStatementReq& TSExecuteBatchStatementReq::operator=(const TSExecuteBatchStatementReq& other121) {
  sessionId = other121.sessionId;
  statements = other121.statements;
  return *this;
}
void TSExecuteBatchStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteBatchStatementReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statements=" << to_string(statements);
  out << ")";
}


TSGetOperationStatusReq::~TSGetOperationStatusReq() noexcept {
}


void TSGetOperationStatusReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSGetOperationStatusReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TSGetOperationStatusReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGetOperationStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGetOperationStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGetOperationStatusReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGetOperationStatusReq &a, TSGetOperationStatusReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
}

TSGetOperationStatusReq::TSGetOperationStatusReq(const TSGetOperationStatusReq& other122) {
  sessionId = other122.sessionId;
  queryId = other122.queryId;
}
TSGetOperationStatusReq& TSGetOperationStatusReq::operator=(const TSGetOperationStatusReq& other123) {
  sessionId = other123.sessionId;
  queryId = other123.queryId;
  return *this;
}
void TSGetOperationStatusReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGetOperationStatusReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId=" << to_string(queryId);
  out << ")";
}


TSCancelOperationReq::~TSCancelOperationReq() noexcept {
}


void TSCancelOperationReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCancelOperationReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TSCancelOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCancelOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCancelOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCancelOperationReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCancelOperationReq &a, TSCancelOperationReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
}

TSCancelOperationReq::TSCancelOperationReq(const TSCancelOperationReq& other124) {
  sessionId = other124.sessionId;
  queryId = other124.queryId;
}
TSCancelOperationReq& TSCancelOperationReq::operator=(const TSCancelOperationReq& other125) {
  sessionId = other125.sessionId;
  queryId = other125.queryId;
  return *this;
}
void TSCancelOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCancelOperationReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId=" << to_string(queryId);
  out << ")";
}


TSCloseOperationReq::~TSCloseOperationReq() noexcept {
}


void TSCloseOperationReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCloseOperationReq::__set_queryId(const int64_t val) {
  this->queryId = val;
__isset.queryId = true;
}

void TSCloseOperationReq::__set_statementId(const int64_t val) {
  this->statementId = val;
__isset.statementId = true;
}
std::ostream& operator<<(std::ostream& out, const TSCloseOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCloseOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          this->__isset.statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCloseOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCloseOperationReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryId) {
    xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->queryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statementId) {
    xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->statementId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCloseOperationReq &a, TSCloseOperationReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
  swap(a.statementId, b.statementId);
  swap(a.__isset, b.__isset);
}

TSCloseOperationReq::TSCloseOperationReq(const TSCloseOperationReq& other126) {
  sessionId = other126.sessionId;
  queryId = other126.queryId;
  statementId = other126.statementId;
  __isset = other126.__isset;
}
TSCloseOperationReq& TSCloseOperationReq::operator=(const TSCloseOperationReq& other127) {
  sessionId = other127.sessionId;
  queryId = other127.queryId;
  statementId = other127.statementId;
  __isset = other127.__isset;
  return *this;
}
void TSCloseOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCloseOperationReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId="; (__isset.queryId ? (out << to_string(queryId)) : (out << "<null>"));
  out << ", " << "statementId="; (__isset.statementId ? (out << to_string(statementId)) : (out << "<null>"));
  out << ")";
}


TSFetchResultsReq::~TSFetchResultsReq() noexcept {
}


void TSFetchResultsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFetchResultsReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TSFetchResultsReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
}

void TSFetchResultsReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}

void TSFetchResultsReq::__set_isAlign(const bool val) {
  this->isAlign = val;
}

void TSFetchResultsReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSFetchResultsReq::__set_statementId(const int64_t val) {
  this->statementId = val;
__isset.statementId = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchResultsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchResultsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statement = false;
  bool isset_fetchSize = false;
  bool isset_queryId = false;
  bool isset_isAlign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          isset_fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAlign);
          isset_isAlign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          this->__isset.statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fetchSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAlign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchResultsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchResultsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->fetchSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAlign", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->isAlign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statementId) {
    xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->statementId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchResultsReq &a, TSFetchResultsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statement, b.statement);
  swap(a.fetchSize, b.fetchSize);
  swap(a.queryId, b.queryId);
  swap(a.isAlign, b.isAlign);
  swap(a.timeout, b.timeout);
  swap(a.statementId, b.statementId);
  swap(a.__isset, b.__isset);
}

TSFetchResultsReq::TSFetchResultsReq(const TSFetchResultsReq& other128) {
  sessionId = other128.sessionId;
  statement = other128.statement;
  fetchSize = other128.fetchSize;
  queryId = other128.queryId;
  isAlign = other128.isAlign;
  timeout = other128.timeout;
  statementId = other128.statementId;
  __isset = other128.__isset;
}
TSFetchResultsReq& TSFetchResultsReq::operator=(const TSFetchResultsReq& other129) {
  sessionId = other129.sessionId;
  statement = other129.statement;
  fetchSize = other129.fetchSize;
  queryId = other129.queryId;
  isAlign = other129.isAlign;
  timeout = other129.timeout;
  statementId = other129.statementId;
  __isset = other129.__isset;
  return *this;
}
void TSFetchResultsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchResultsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "fetchSize=" << to_string(fetchSize);
  out << ", " << "queryId=" << to_string(queryId);
  out << ", " << "isAlign=" << to_string(isAlign);
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "statementId="; (__isset.statementId ? (out << to_string(statementId)) : (out << "<null>"));
  out << ")";
}


TSFetchResultsResp::~TSFetchResultsResp() noexcept {
}


void TSFetchResultsResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSFetchResultsResp::__set_hasResultSet(const bool val) {
  this->hasResultSet = val;
}

void TSFetchResultsResp::__set_isAlign(const bool val) {
  this->isAlign = val;
}

void TSFetchResultsResp::__set_queryDataSet(const TSQueryDataSet& val) {
  this->queryDataSet = val;
__isset.queryDataSet = true;
}

void TSFetchResultsResp::__set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val) {
  this->nonAlignQueryDataSet = val;
__isset.nonAlignQueryDataSet = true;
}

void TSFetchResultsResp::__set_queryResult(const std::vector<std::string> & val) {
  this->queryResult = val;
__isset.queryResult = true;
}

void TSFetchResultsResp::__set_moreData(const bool val) {
  this->moreData = val;
__isset.moreData = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchResultsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchResultsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_hasResultSet = false;
  bool isset_isAlign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          isset_hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAlign);
          isset_isAlign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryDataSet.read(iprot);
          this->__isset.queryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nonAlignQueryDataSet.read(iprot);
          this->__isset.nonAlignQueryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->queryResult.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->queryResult.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              xfer += iprot->readBinary(this->queryResult[_i134]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.queryResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->moreData);
          this->__isset.moreData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasResultSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAlign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchResultsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchResultsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasResultSet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAlign", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isAlign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryDataSet) {
    xfer += oprot->writeFieldBegin("queryDataSet", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->queryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nonAlignQueryDataSet) {
    xfer += oprot->writeFieldBegin("nonAlignQueryDataSet", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->nonAlignQueryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryResult) {
    xfer += oprot->writeFieldBegin("queryResult", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->queryResult.size()));
      std::vector<std::string> ::const_iterator _iter135;
      for (_iter135 = this->queryResult.begin(); _iter135 != this->queryResult.end(); ++_iter135)
      {
        xfer += oprot->writeBinary((*_iter135));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.moreData) {
    xfer += oprot->writeFieldBegin("moreData", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->moreData);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchResultsResp &a, TSFetchResultsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.isAlign, b.isAlign);
  swap(a.queryDataSet, b.queryDataSet);
  swap(a.nonAlignQueryDataSet, b.nonAlignQueryDataSet);
  swap(a.queryResult, b.queryResult);
  swap(a.moreData, b.moreData);
  swap(a.__isset, b.__isset);
}

TSFetchResultsResp::TSFetchResultsResp(const TSFetchResultsResp& other136) {
  status = other136.status;
  hasResultSet = other136.hasResultSet;
  isAlign = other136.isAlign;
  queryDataSet = other136.queryDataSet;
  nonAlignQueryDataSet = other136.nonAlignQueryDataSet;
  queryResult = other136.queryResult;
  moreData = other136.moreData;
  __isset = other136.__isset;
}
TSFetchResultsResp& TSFetchResultsResp::operator=(const TSFetchResultsResp& other137) {
  status = other137.status;
  hasResultSet = other137.hasResultSet;
  isAlign = other137.isAlign;
  queryDataSet = other137.queryDataSet;
  nonAlignQueryDataSet = other137.nonAlignQueryDataSet;
  queryResult = other137.queryResult;
  moreData = other137.moreData;
  __isset = other137.__isset;
  return *this;
}
void TSFetchResultsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchResultsResp(";
  out << "status=" << to_string(status);
  out << ", " << "hasResultSet=" << to_string(hasResultSet);
  out << ", " << "isAlign=" << to_string(isAlign);
  out << ", " << "queryDataSet="; (__isset.queryDataSet ? (out << to_string(queryDataSet)) : (out << "<null>"));
  out << ", " << "nonAlignQueryDataSet="; (__isset.nonAlignQueryDataSet ? (out << to_string(nonAlignQueryDataSet)) : (out << "<null>"));
  out << ", " << "queryResult="; (__isset.queryResult ? (out << to_string(queryResult)) : (out << "<null>"));
  out << ", " << "moreData="; (__isset.moreData ? (out << to_string(moreData)) : (out << "<null>"));
  out << ")";
}


TSFetchMetadataResp::~TSFetchMetadataResp() noexcept {
}


void TSFetchMetadataResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSFetchMetadataResp::__set_metadataInJson(const std::string& val) {
  this->metadataInJson = val;
__isset.metadataInJson = true;
}

void TSFetchMetadataResp::__set_columnsList(const std::vector<std::string> & val) {
  this->columnsList = val;
__isset.columnsList = true;
}

void TSFetchMetadataResp::__set_dataType(const std::string& val) {
  this->dataType = val;
__isset.dataType = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchMetadataResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchMetadataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadataInJson);
          this->__isset.metadataInJson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnsList.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            this->columnsList.resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += iprot->readString(this->columnsList[_i142]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchMetadataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchMetadataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metadataInJson) {
    xfer += oprot->writeFieldBegin("metadataInJson", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->metadataInJson);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnsList) {
    xfer += oprot->writeFieldBegin("columnsList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columnsList.size()));
      std::vector<std::string> ::const_iterator _iter143;
      for (_iter143 = this->columnsList.begin(); _iter143 != this->columnsList.end(); ++_iter143)
      {
        xfer += oprot->writeString((*_iter143));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataType) {
    xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dataType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchMetadataResp &a, TSFetchMetadataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.metadataInJson, b.metadataInJson);
  swap(a.columnsList, b.columnsList);
  swap(a.dataType, b.dataType);
  swap(a.__isset, b.__isset);
}

TSFetchMetadataResp::TSFetchMetadataResp(const TSFetchMetadataResp& other144) {
  status = other144.status;
  metadataInJson = other144.metadataInJson;
  columnsList = other144.columnsList;
  dataType = other144.dataType;
  __isset = other144.__isset;
}
TSFetchMetadataResp& TSFetchMetadataResp::operator=(const TSFetchMetadataResp& other145) {
  status = other145.status;
  metadataInJson = other145.metadataInJson;
  columnsList = other145.columnsList;
  dataType = other145.dataType;
  __isset = other145.__isset;
  return *this;
}
void TSFetchMetadataResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchMetadataResp(";
  out << "status=" << to_string(status);
  out << ", " << "metadataInJson="; (__isset.metadataInJson ? (out << to_string(metadataInJson)) : (out << "<null>"));
  out << ", " << "columnsList="; (__isset.columnsList ? (out << to_string(columnsList)) : (out << "<null>"));
  out << ", " << "dataType="; (__isset.dataType ? (out << to_string(dataType)) : (out << "<null>"));
  out << ")";
}


TSFetchMetadataReq::~TSFetchMetadataReq() noexcept {
}


void TSFetchMetadataReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFetchMetadataReq::__set_type(const std::string& val) {
  this->type = val;
}

void TSFetchMetadataReq::__set_columnPath(const std::string& val) {
  this->columnPath = val;
__isset.columnPath = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchMetadataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchMetadataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnPath);
          this->__isset.columnPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchMetadataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchMetadataReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columnPath) {
    xfer += oprot->writeFieldBegin("columnPath", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->columnPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchMetadataReq &a, TSFetchMetadataReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.type, b.type);
  swap(a.columnPath, b.columnPath);
  swap(a.__isset, b.__isset);
}

TSFetchMetadataReq::TSFetchMetadataReq(const TSFetchMetadataReq& other146) {
  sessionId = other146.sessionId;
  type = other146.type;
  columnPath = other146.columnPath;
  __isset = other146.__isset;
}
TSFetchMetadataReq& TSFetchMetadataReq::operator=(const TSFetchMetadataReq& other147) {
  sessionId = other147.sessionId;
  type = other147.type;
  columnPath = other147.columnPath;
  __isset = other147.__isset;
  return *this;
}
void TSFetchMetadataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchMetadataReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "type=" << to_string(type);
  out << ", " << "columnPath="; (__isset.columnPath ? (out << to_string(columnPath)) : (out << "<null>"));
  out << ")";
}


TSGetTimeZoneResp::~TSGetTimeZoneResp() noexcept {
}


void TSGetTimeZoneResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSGetTimeZoneResp::__set_timeZone(const std::string& val) {
  this->timeZone = val;
}
std::ostream& operator<<(std::ostream& out, const TSGetTimeZoneResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGetTimeZoneResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_timeZone = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          isset_timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGetTimeZoneResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGetTimeZoneResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGetTimeZoneResp &a, TSGetTimeZoneResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.timeZone, b.timeZone);
}

TSGetTimeZoneResp::TSGetTimeZoneResp(const TSGetTimeZoneResp& other148) {
  status = other148.status;
  timeZone = other148.timeZone;
}
TSGetTimeZoneResp& TSGetTimeZoneResp::operator=(const TSGetTimeZoneResp& other149) {
  status = other149.status;
  timeZone = other149.timeZone;
  return *this;
}
void TSGetTimeZoneResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGetTimeZoneResp(";
  out << "status=" << to_string(status);
  out << ", " << "timeZone=" << to_string(timeZone);
  out << ")";
}


TSSetTimeZoneReq::~TSSetTimeZoneReq() noexcept {
}


void TSSetTimeZoneReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSSetTimeZoneReq::__set_timeZone(const std::string& val) {
  this->timeZone = val;
}
std::ostream& operator<<(std::ostream& out, const TSSetTimeZoneReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSSetTimeZoneReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_timeZone = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          isset_timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSSetTimeZoneReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSSetTimeZoneReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSSetTimeZoneReq &a, TSSetTimeZoneReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.timeZone, b.timeZone);
}

TSSetTimeZoneReq::TSSetTimeZoneReq(const TSSetTimeZoneReq& other150) {
  sessionId = other150.sessionId;
  timeZone = other150.timeZone;
}
TSSetTimeZoneReq& TSSetTimeZoneReq::operator=(const TSSetTimeZoneReq& other151) {
  sessionId = other151.sessionId;
  timeZone = other151.timeZone;
  return *this;
}
void TSSetTimeZoneReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSSetTimeZoneReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "timeZone=" << to_string(timeZone);
  out << ")";
}


TSInsertRecordReq::~TSInsertRecordReq() noexcept {
}


void TSInsertRecordReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSInsertRecordReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertRecordReq::__set_values(const std::string& val) {
  this->values = val;
}

void TSInsertRecordReq::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void TSInsertRecordReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}

void TSInsertRecordReq::__set_isWriteToTable(const bool val) {
  this->isWriteToTable = val;
__isset.isWriteToTable = true;
}

void TSInsertRecordReq::__set_columnCategoryies(const std::vector<int8_t> & val) {
  this->columnCategoryies = val;
__isset.columnCategoryies = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size152;
            ::apache::thrift::protocol::TType _etype155;
            xfer += iprot->readListBegin(_etype155, _size152);
            this->measurements.resize(_size152);
            uint32_t _i156;
            for (_i156 = 0; _i156 < _size152; ++_i156)
            {
              xfer += iprot->readString(this->measurements[_i156]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->values);
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isWriteToTable);
          this->__isset.isWriteToTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnCategoryies.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            this->columnCategoryies.resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += iprot->readByte(this->columnCategoryies[_i161]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnCategoryies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter162;
    for (_iter162 = this->measurements.begin(); _iter162 != this->measurements.end(); ++_iter162)
    {
      xfer += oprot->writeString((*_iter162));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isWriteToTable) {
    xfer += oprot->writeFieldBegin("isWriteToTable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isWriteToTable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnCategoryies) {
    xfer += oprot->writeFieldBegin("columnCategoryies", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->columnCategoryies.size()));
      std::vector<int8_t> ::const_iterator _iter163;
      for (_iter163 = this->columnCategoryies.begin(); _iter163 != this->columnCategoryies.end(); ++_iter163)
      {
        xfer += oprot->writeByte((*_iter163));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordReq &a, TSInsertRecordReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamp, b.timestamp);
  swap(a.isAligned, b.isAligned);
  swap(a.isWriteToTable, b.isWriteToTable);
  swap(a.columnCategoryies, b.columnCategoryies);
  swap(a.__isset, b.__isset);
}

TSInsertRecordReq::TSInsertRecordReq(const TSInsertRecordReq& other164) {
  sessionId = other164.sessionId;
  prefixPath = other164.prefixPath;
  measurements = other164.measurements;
  values = other164.values;
  timestamp = other164.timestamp;
  isAligned = other164.isAligned;
  isWriteToTable = other164.isWriteToTable;
  columnCategoryies = other164.columnCategoryies;
  __isset = other164.__isset;
}
TSInsertRecordReq& TSInsertRecordReq::operator=(const TSInsertRecordReq& other165) {
  sessionId = other165.sessionId;
  prefixPath = other165.prefixPath;
  measurements = other165.measurements;
  values = other165.values;
  timestamp = other165.timestamp;
  isAligned = other165.isAligned;
  isWriteToTable = other165.isWriteToTable;
  columnCategoryies = other165.columnCategoryies;
  __isset = other165.__isset;
  return *this;
}
void TSInsertRecordReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ", " << "isWriteToTable="; (__isset.isWriteToTable ? (out << to_string(isWriteToTable)) : (out << "<null>"));
  out << ", " << "columnCategoryies="; (__isset.columnCategoryies ? (out << to_string(columnCategoryies)) : (out << "<null>"));
  out << ")";
}


TSInsertStringRecordReq::~TSInsertStringRecordReq() noexcept {
}


void TSInsertStringRecordReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertStringRecordReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSInsertStringRecordReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertStringRecordReq::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void TSInsertStringRecordReq::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void TSInsertStringRecordReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}

void TSInsertStringRecordReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertStringRecordReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->measurements.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += iprot->readString(this->measurements[_i170]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->values.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += iprot->readString(this->values[_i175]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertStringRecordReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertStringRecordReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter176;
    for (_iter176 = this->measurements.begin(); _iter176 != this->measurements.end(); ++_iter176)
    {
      xfer += oprot->writeString((*_iter176));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter177;
    for (_iter177 = this->values.begin(); _iter177 != this->values.end(); ++_iter177)
    {
      xfer += oprot->writeString((*_iter177));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertStringRecordReq &a, TSInsertStringRecordReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamp, b.timestamp);
  swap(a.isAligned, b.isAligned);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

TSInsertStringRecordReq::TSInsertStringRecordReq(const TSInsertStringRecordReq& other178) {
  sessionId = other178.sessionId;
  prefixPath = other178.prefixPath;
  measurements = other178.measurements;
  values = other178.values;
  timestamp = other178.timestamp;
  isAligned = other178.isAligned;
  timeout = other178.timeout;
  __isset = other178.__isset;
}
TSInsertStringRecordReq& TSInsertStringRecordReq::operator=(const TSInsertStringRecordReq& other179) {
  sessionId = other179.sessionId;
  prefixPath = other179.prefixPath;
  measurements = other179.measurements;
  values = other179.values;
  timestamp = other179.timestamp;
  isAligned = other179.isAligned;
  timeout = other179.timeout;
  __isset = other179.__isset;
  return *this;
}
void TSInsertStringRecordReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertStringRecordReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


TSInsertTabletReq::~TSInsertTabletReq() noexcept {
}


void TSInsertTabletReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertTabletReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSInsertTabletReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertTabletReq::__set_values(const std::string& val) {
  this->values = val;
}

void TSInsertTabletReq::__set_timestamps(const std::string& val) {
  this->timestamps = val;
}

void TSInsertTabletReq::__set_types(const std::vector<int32_t> & val) {
  this->types = val;
}

void TSInsertTabletReq::__set_size(const int32_t val) {
  this->size = val;
}

void TSInsertTabletReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}

void TSInsertTabletReq::__set_writeToTable(const bool val) {
  this->writeToTable = val;
__isset.writeToTable = true;
}

void TSInsertTabletReq::__set_columnCategories(const std::vector<int8_t> & val) {
  this->columnCategories = val;
__isset.columnCategories = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertTabletReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamps = false;
  bool isset_types = false;
  bool isset_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->measurements.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readString(this->measurements[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->values);
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->timestamps);
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->types.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += iprot->readI32(this->types[_i189]);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->writeToTable);
          this->__isset.writeToTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnCategories.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->columnCategories.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += iprot->readByte(this->columnCategories[_i194]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnCategories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertTabletReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter195;
    for (_iter195 = this->measurements.begin(); _iter195 != this->measurements.end(); ++_iter195)
    {
      xfer += oprot->writeString((*_iter195));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->timestamps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->types.size()));
    std::vector<int32_t> ::const_iterator _iter196;
    for (_iter196 = this->types.begin(); _iter196 != this->types.end(); ++_iter196)
    {
      xfer += oprot->writeI32((*_iter196));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.writeToTable) {
    xfer += oprot->writeFieldBegin("writeToTable", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->writeToTable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnCategories) {
    xfer += oprot->writeFieldBegin("columnCategories", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->columnCategories.size()));
      std::vector<int8_t> ::const_iterator _iter197;
      for (_iter197 = this->columnCategories.begin(); _iter197 != this->columnCategories.end(); ++_iter197)
      {
        xfer += oprot->writeByte((*_iter197));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertTabletReq &a, TSInsertTabletReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamps, b.timestamps);
  swap(a.types, b.types);
  swap(a.size, b.size);
  swap(a.isAligned, b.isAligned);
  swap(a.writeToTable, b.writeToTable);
  swap(a.columnCategories, b.columnCategories);
  swap(a.__isset, b.__isset);
}

TSInsertTabletReq::TSInsertTabletReq(const TSInsertTabletReq& other198) {
  sessionId = other198.sessionId;
  prefixPath = other198.prefixPath;
  measurements = other198.measurements;
  values = other198.values;
  timestamps = other198.timestamps;
  types = other198.types;
  size = other198.size;
  isAligned = other198.isAligned;
  writeToTable = other198.writeToTable;
  columnCategories = other198.columnCategories;
  __isset = other198.__isset;
}
TSInsertTabletReq& TSInsertTabletReq::operator=(const TSInsertTabletReq& other199) {
  sessionId = other199.sessionId;
  prefixPath = other199.prefixPath;
  measurements = other199.measurements;
  values = other199.values;
  timestamps = other199.timestamps;
  types = other199.types;
  size = other199.size;
  isAligned = other199.isAligned;
  writeToTable = other199.writeToTable;
  columnCategories = other199.columnCategories;
  __isset = other199.__isset;
  return *this;
}
void TSInsertTabletReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertTabletReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "types=" << to_string(types);
  out << ", " << "size=" << to_string(size);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ", " << "writeToTable="; (__isset.writeToTable ? (out << to_string(writeToTable)) : (out << "<null>"));
  out << ", " << "columnCategories="; (__isset.columnCategories ? (out << to_string(columnCategories)) : (out << "<null>"));
  out << ")";
}


TSInsertTabletsReq::~TSInsertTabletsReq() noexcept {
}


void TSInsertTabletsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertTabletsReq::__set_prefixPaths(const std::vector<std::string> & val) {
  this->prefixPaths = val;
}

void TSInsertTabletsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertTabletsReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertTabletsReq::__set_timestampsList(const std::vector<std::string> & val) {
  this->timestampsList = val;
}

void TSInsertTabletsReq::__set_typesList(const std::vector<std::vector<int32_t> > & val) {
  this->typesList = val;
}

void TSInsertTabletsReq::__set_sizeList(const std::vector<int32_t> & val) {
  this->sizeList = val;
}

void TSInsertTabletsReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertTabletsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertTabletsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPaths = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestampsList = false;
  bool isset_typesList = false;
  bool isset_sizeList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->prefixPaths.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->prefixPaths.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += iprot->readString(this->prefixPaths[_i204]);
            }
            xfer += iprot->readListEnd();
          }
          isset_prefixPaths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->measurementsList.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              {
                this->measurementsList[_i209].clear();
                uint32_t _size210;
                ::apache::thrift::protocol::TType _etype213;
                xfer += iprot->readListBegin(_etype213, _size210);
                this->measurementsList[_i209].resize(_size210);
                uint32_t _i214;
                for (_i214 = 0; _i214 < _size210; ++_i214)
                {
                  xfer += iprot->readString(this->measurementsList[_i209][_i214]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size215;
            ::apache::thrift::protocol::TType _etype218;
            xfer += iprot->readListBegin(_etype218, _size215);
            this->valuesList.resize(_size215);
            uint32_t _i219;
            for (_i219 = 0; _i219 < _size215; ++_i219)
            {
              xfer += iprot->readBinary(this->valuesList[_i219]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestampsList.clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _etype223;
            xfer += iprot->readListBegin(_etype223, _size220);
            this->timestampsList.resize(_size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              xfer += iprot->readBinary(this->timestampsList[_i224]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestampsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->typesList.clear();
            uint32_t _size225;
            ::apache::thrift::protocol::TType _etype228;
            xfer += iprot->readListBegin(_etype228, _size225);
            this->typesList.resize(_size225);
            uint32_t _i229;
            for (_i229 = 0; _i229 < _size225; ++_i229)
            {
              {
                this->typesList[_i229].clear();
                uint32_t _size230;
                ::apache::thrift::protocol::TType _etype233;
                xfer += iprot->readListBegin(_etype233, _size230);
                this->typesList[_i229].resize(_size230);
                uint32_t _i234;
                for (_i234 = 0; _i234 < _size230; ++_i234)
                {
                  xfer += iprot->readI32(this->typesList[_i229][_i234]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_typesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sizeList.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _etype238;
            xfer += iprot->readListBegin(_etype238, _size235);
            this->sizeList.resize(_size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              xfer += iprot->readI32(this->sizeList[_i239]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sizeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPaths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestampsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sizeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertTabletsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertTabletsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPaths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->prefixPaths.size()));
    std::vector<std::string> ::const_iterator _iter240;
    for (_iter240 = this->prefixPaths.begin(); _iter240 != this->prefixPaths.end(); ++_iter240)
    {
      xfer += oprot->writeString((*_iter240));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter241;
    for (_iter241 = this->measurementsList.begin(); _iter241 != this->measurementsList.end(); ++_iter241)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter241).size()));
        std::vector<std::string> ::const_iterator _iter242;
        for (_iter242 = (*_iter241).begin(); _iter242 != (*_iter241).end(); ++_iter242)
        {
          xfer += oprot->writeString((*_iter242));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter243;
    for (_iter243 = this->valuesList.begin(); _iter243 != this->valuesList.end(); ++_iter243)
    {
      xfer += oprot->writeBinary((*_iter243));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestampsList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->timestampsList.size()));
    std::vector<std::string> ::const_iterator _iter244;
    for (_iter244 = this->timestampsList.begin(); _iter244 != this->timestampsList.end(); ++_iter244)
    {
      xfer += oprot->writeBinary((*_iter244));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typesList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->typesList.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter245;
    for (_iter245 = this->typesList.begin(); _iter245 != this->typesList.end(); ++_iter245)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter245).size()));
        std::vector<int32_t> ::const_iterator _iter246;
        for (_iter246 = (*_iter245).begin(); _iter246 != (*_iter245).end(); ++_iter246)
        {
          xfer += oprot->writeI32((*_iter246));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizeList", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sizeList.size()));
    std::vector<int32_t> ::const_iterator _iter247;
    for (_iter247 = this->sizeList.begin(); _iter247 != this->sizeList.end(); ++_iter247)
    {
      xfer += oprot->writeI32((*_iter247));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertTabletsReq &a, TSInsertTabletsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPaths, b.prefixPaths);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestampsList, b.timestampsList);
  swap(a.typesList, b.typesList);
  swap(a.sizeList, b.sizeList);
  swap(a.isAligned, b.isAligned);
  swap(a.__isset, b.__isset);
}

TSInsertTabletsReq::TSInsertTabletsReq(const TSInsertTabletsReq& other248) {
  sessionId = other248.sessionId;
  prefixPaths = other248.prefixPaths;
  measurementsList = other248.measurementsList;
  valuesList = other248.valuesList;
  timestampsList = other248.timestampsList;
  typesList = other248.typesList;
  sizeList = other248.sizeList;
  isAligned = other248.isAligned;
  __isset = other248.__isset;
}
TSInsertTabletsReq& TSInsertTabletsReq::operator=(const TSInsertTabletsReq& other249) {
  sessionId = other249.sessionId;
  prefixPaths = other249.prefixPaths;
  measurementsList = other249.measurementsList;
  valuesList = other249.valuesList;
  timestampsList = other249.timestampsList;
  typesList = other249.typesList;
  sizeList = other249.sizeList;
  isAligned = other249.isAligned;
  __isset = other249.__isset;
  return *this;
}
void TSInsertTabletsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertTabletsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPaths=" << to_string(prefixPaths);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestampsList=" << to_string(timestampsList);
  out << ", " << "typesList=" << to_string(typesList);
  out << ", " << "sizeList=" << to_string(sizeList);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ")";
}


TSInsertRecordsReq::~TSInsertRecordsReq() noexcept {
}


void TSInsertRecordsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordsReq::__set_prefixPaths(const std::vector<std::string> & val) {
  this->prefixPaths = val;
}

void TSInsertRecordsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertRecordsReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertRecordsReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}

void TSInsertRecordsReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPaths = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->prefixPaths.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _etype253;
            xfer += iprot->readListBegin(_etype253, _size250);
            this->prefixPaths.resize(_size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              xfer += iprot->readString(this->prefixPaths[_i254]);
            }
            xfer += iprot->readListEnd();
          }
          isset_prefixPaths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size255;
            ::apache::thrift::protocol::TType _etype258;
            xfer += iprot->readListBegin(_etype258, _size255);
            this->measurementsList.resize(_size255);
            uint32_t _i259;
            for (_i259 = 0; _i259 < _size255; ++_i259)
            {
              {
                this->measurementsList[_i259].clear();
                uint32_t _size260;
                ::apache::thrift::protocol::TType _etype263;
                xfer += iprot->readListBegin(_etype263, _size260);
                this->measurementsList[_i259].resize(_size260);
                uint32_t _i264;
                for (_i264 = 0; _i264 < _size260; ++_i264)
                {
                  xfer += iprot->readString(this->measurementsList[_i259][_i264]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size265;
            ::apache::thrift::protocol::TType _etype268;
            xfer += iprot->readListBegin(_etype268, _size265);
            this->valuesList.resize(_size265);
            uint32_t _i269;
            for (_i269 = 0; _i269 < _size265; ++_i269)
            {
              xfer += iprot->readBinary(this->valuesList[_i269]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size270;
            ::apache::thrift::protocol::TType _etype273;
            xfer += iprot->readListBegin(_etype273, _size270);
            this->timestamps.resize(_size270);
            uint32_t _i274;
            for (_i274 = 0; _i274 < _size270; ++_i274)
            {
              xfer += iprot->readI64(this->timestamps[_i274]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPaths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPaths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->prefixPaths.size()));
    std::vector<std::string> ::const_iterator _iter275;
    for (_iter275 = this->prefixPaths.begin(); _iter275 != this->prefixPaths.end(); ++_iter275)
    {
      xfer += oprot->writeString((*_iter275));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter276;
    for (_iter276 = this->measurementsList.begin(); _iter276 != this->measurementsList.end(); ++_iter276)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter276).size()));
        std::vector<std::string> ::const_iterator _iter277;
        for (_iter277 = (*_iter276).begin(); _iter277 != (*_iter276).end(); ++_iter277)
        {
          xfer += oprot->writeString((*_iter277));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter278;
    for (_iter278 = this->valuesList.begin(); _iter278 != this->valuesList.end(); ++_iter278)
    {
      xfer += oprot->writeBinary((*_iter278));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter279;
    for (_iter279 = this->timestamps.begin(); _iter279 != this->timestamps.end(); ++_iter279)
    {
      xfer += oprot->writeI64((*_iter279));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordsReq &a, TSInsertRecordsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPaths, b.prefixPaths);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
  swap(a.isAligned, b.isAligned);
  swap(a.__isset, b.__isset);
}

TSInsertRecordsReq::TSInsertRecordsReq(const TSInsertRecordsReq& other280) {
  sessionId = other280.sessionId;
  prefixPaths = other280.prefixPaths;
  measurementsList = other280.measurementsList;
  valuesList = other280.valuesList;
  timestamps = other280.timestamps;
  isAligned = other280.isAligned;
  __isset = other280.__isset;
}
TSInsertRecordsReq& TSInsertRecordsReq::operator=(const TSInsertRecordsReq& other281) {
  sessionId = other281.sessionId;
  prefixPaths = other281.prefixPaths;
  measurementsList = other281.measurementsList;
  valuesList = other281.valuesList;
  timestamps = other281.timestamps;
  isAligned = other281.isAligned;
  __isset = other281.__isset;
  return *this;
}
void TSInsertRecordsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPaths=" << to_string(prefixPaths);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ")";
}


TSInsertRecordsOfOneDeviceReq::~TSInsertRecordsOfOneDeviceReq() noexcept {
}


void TSInsertRecordsOfOneDeviceReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}

void TSInsertRecordsOfOneDeviceReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordsOfOneDeviceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordsOfOneDeviceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _etype285;
            xfer += iprot->readListBegin(_etype285, _size282);
            this->measurementsList.resize(_size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              {
                this->measurementsList[_i286].clear();
                uint32_t _size287;
                ::apache::thrift::protocol::TType _etype290;
                xfer += iprot->readListBegin(_etype290, _size287);
                this->measurementsList[_i286].resize(_size287);
                uint32_t _i291;
                for (_i291 = 0; _i291 < _size287; ++_i291)
                {
                  xfer += iprot->readString(this->measurementsList[_i286][_i291]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _etype295;
            xfer += iprot->readListBegin(_etype295, _size292);
            this->valuesList.resize(_size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              xfer += iprot->readBinary(this->valuesList[_i296]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->timestamps.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += iprot->readI64(this->timestamps[_i301]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordsOfOneDeviceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordsOfOneDeviceReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter302;
    for (_iter302 = this->measurementsList.begin(); _iter302 != this->measurementsList.end(); ++_iter302)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter302).size()));
        std::vector<std::string> ::const_iterator _iter303;
        for (_iter303 = (*_iter302).begin(); _iter303 != (*_iter302).end(); ++_iter303)
        {
          xfer += oprot->writeString((*_iter303));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter304;
    for (_iter304 = this->valuesList.begin(); _iter304 != this->valuesList.end(); ++_iter304)
    {
      xfer += oprot->writeBinary((*_iter304));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter305;
    for (_iter305 = this->timestamps.begin(); _iter305 != this->timestamps.end(); ++_iter305)
    {
      xfer += oprot->writeI64((*_iter305));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordsOfOneDeviceReq &a, TSInsertRecordsOfOneDeviceReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
  swap(a.isAligned, b.isAligned);
  swap(a.__isset, b.__isset);
}

TSInsertRecordsOfOneDeviceReq::TSInsertRecordsOfOneDeviceReq(const TSInsertRecordsOfOneDeviceReq& other306) {
  sessionId = other306.sessionId;
  prefixPath = other306.prefixPath;
  measurementsList = other306.measurementsList;
  valuesList = other306.valuesList;
  timestamps = other306.timestamps;
  isAligned = other306.isAligned;
  __isset = other306.__isset;
}
TSInsertRecordsOfOneDeviceReq& TSInsertRecordsOfOneDeviceReq::operator=(const TSInsertRecordsOfOneDeviceReq& other307) {
  sessionId = other307.sessionId;
  prefixPath = other307.prefixPath;
  measurementsList = other307.measurementsList;
  valuesList = other307.valuesList;
  timestamps = other307.timestamps;
  isAligned = other307.isAligned;
  __isset = other307.__isset;
  return *this;
}
void TSInsertRecordsOfOneDeviceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordsOfOneDeviceReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ")";
}


TSInsertStringRecordsOfOneDeviceReq::~TSInsertStringRecordsOfOneDeviceReq() noexcept {
}


void TSInsertStringRecordsOfOneDeviceReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertStringRecordsOfOneDeviceReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSInsertStringRecordsOfOneDeviceReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertStringRecordsOfOneDeviceReq::__set_valuesList(const std::vector<std::vector<std::string> > & val) {
  this->valuesList = val;
}

void TSInsertStringRecordsOfOneDeviceReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}

void TSInsertStringRecordsOfOneDeviceReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordsOfOneDeviceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertStringRecordsOfOneDeviceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size308;
            ::apache::thrift::protocol::TType _etype311;
            xfer += iprot->readListBegin(_etype311, _size308);
            this->measurementsList.resize(_size308);
            uint32_t _i312;
            for (_i312 = 0; _i312 < _size308; ++_i312)
            {
              {
                this->measurementsList[_i312].clear();
                uint32_t _size313;
                ::apache::thrift::protocol::TType _etype316;
                xfer += iprot->readListBegin(_etype316, _size313);
                this->measurementsList[_i312].resize(_size313);
                uint32_t _i317;
                for (_i317 = 0; _i317 < _size313; ++_i317)
                {
                  xfer += iprot->readString(this->measurementsList[_i312][_i317]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size318;
            ::apache::thrift::protocol::TType _etype321;
            xfer += iprot->readListBegin(_etype321, _size318);
            this->valuesList.resize(_size318);
            uint32_t _i322;
            for (_i322 = 0; _i322 < _size318; ++_i322)
            {
              {
                this->valuesList[_i322].clear();
                uint32_t _size323;
                ::apache::thrift::protocol::TType _etype326;
                xfer += iprot->readListBegin(_etype326, _size323);
                this->valuesList[_i322].resize(_size323);
                uint32_t _i327;
                for (_i327 = 0; _i327 < _size323; ++_i327)
                {
                  xfer += iprot->readString(this->valuesList[_i322][_i327]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _etype331;
            xfer += iprot->readListBegin(_etype331, _size328);
            this->timestamps.resize(_size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              xfer += iprot->readI64(this->timestamps[_i332]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertStringRecordsOfOneDeviceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertStringRecordsOfOneDeviceReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter333;
    for (_iter333 = this->measurementsList.begin(); _iter333 != this->measurementsList.end(); ++_iter333)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter333).size()));
        std::vector<std::string> ::const_iterator _iter334;
        for (_iter334 = (*_iter333).begin(); _iter334 != (*_iter333).end(); ++_iter334)
        {
          xfer += oprot->writeString((*_iter334));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter335;
    for (_iter335 = this->valuesList.begin(); _iter335 != this->valuesList.end(); ++_iter335)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter335).size()));
        std::vector<std::string> ::const_iterator _iter336;
        for (_iter336 = (*_iter335).begin(); _iter336 != (*_iter335).end(); ++_iter336)
        {
          xfer += oprot->writeString((*_iter336));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter337;
    for (_iter337 = this->timestamps.begin(); _iter337 != this->timestamps.end(); ++_iter337)
    {
      xfer += oprot->writeI64((*_iter337));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertStringRecordsOfOneDeviceReq &a, TSInsertStringRecordsOfOneDeviceReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
  swap(a.isAligned, b.isAligned);
  swap(a.__isset, b.__isset);
}

TSInsertStringRecordsOfOneDeviceReq::TSInsertStringRecordsOfOneDeviceReq(const TSInsertStringRecordsOfOneDeviceReq& other338) {
  sessionId = other338.sessionId;
  prefixPath = other338.prefixPath;
  measurementsList = other338.measurementsList;
  valuesList = other338.valuesList;
  timestamps = other338.timestamps;
  isAligned = other338.isAligned;
  __isset = other338.__isset;
}
TSInsertStringRecordsOfOneDeviceReq& TSInsertStringRecordsOfOneDeviceReq::operator=(const TSInsertStringRecordsOfOneDeviceReq& other339) {
  sessionId = other339.sessionId;
  prefixPath = other339.prefixPath;
  measurementsList = other339.measurementsList;
  valuesList = other339.valuesList;
  timestamps = other339.timestamps;
  isAligned = other339.isAligned;
  __isset = other339.__isset;
  return *this;
}
void TSInsertStringRecordsOfOneDeviceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertStringRecordsOfOneDeviceReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ")";
}


TSInsertStringRecordsReq::~TSInsertStringRecordsReq() noexcept {
}


void TSInsertStringRecordsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertStringRecordsReq::__set_prefixPaths(const std::vector<std::string> & val) {
  this->prefixPaths = val;
}

void TSInsertStringRecordsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertStringRecordsReq::__set_valuesList(const std::vector<std::vector<std::string> > & val) {
  this->valuesList = val;
}

void TSInsertStringRecordsReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}

void TSInsertStringRecordsReq::__set_isAligned(const bool val) {
  this->isAligned = val;
__isset.isAligned = true;
}
std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertStringRecordsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPaths = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->prefixPaths.clear();
            uint32_t _size340;
            ::apache::thrift::protocol::TType _etype343;
            xfer += iprot->readListBegin(_etype343, _size340);
            this->prefixPaths.resize(_size340);
            uint32_t _i344;
            for (_i344 = 0; _i344 < _size340; ++_i344)
            {
              xfer += iprot->readString(this->prefixPaths[_i344]);
            }
            xfer += iprot->readListEnd();
          }
          isset_prefixPaths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size345;
            ::apache::thrift::protocol::TType _etype348;
            xfer += iprot->readListBegin(_etype348, _size345);
            this->measurementsList.resize(_size345);
            uint32_t _i349;
            for (_i349 = 0; _i349 < _size345; ++_i349)
            {
              {
                this->measurementsList[_i349].clear();
                uint32_t _size350;
                ::apache::thrift::protocol::TType _etype353;
                xfer += iprot->readListBegin(_etype353, _size350);
                this->measurementsList[_i349].resize(_size350);
                uint32_t _i354;
                for (_i354 = 0; _i354 < _size350; ++_i354)
                {
                  xfer += iprot->readString(this->measurementsList[_i349][_i354]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size355;
            ::apache::thrift::protocol::TType _etype358;
            xfer += iprot->readListBegin(_etype358, _size355);
            this->valuesList.resize(_size355);
            uint32_t _i359;
            for (_i359 = 0; _i359 < _size355; ++_i359)
            {
              {
                this->valuesList[_i359].clear();
                uint32_t _size360;
                ::apache::thrift::protocol::TType _etype363;
                xfer += iprot->readListBegin(_etype363, _size360);
                this->valuesList[_i359].resize(_size360);
                uint32_t _i364;
                for (_i364 = 0; _i364 < _size360; ++_i364)
                {
                  xfer += iprot->readString(this->valuesList[_i359][_i364]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size365;
            ::apache::thrift::protocol::TType _etype368;
            xfer += iprot->readListBegin(_etype368, _size365);
            this->timestamps.resize(_size365);
            uint32_t _i369;
            for (_i369 = 0; _i369 < _size365; ++_i369)
            {
              xfer += iprot->readI64(this->timestamps[_i369]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          this->__isset.isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPaths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertStringRecordsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertStringRecordsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPaths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->prefixPaths.size()));
    std::vector<std::string> ::const_iterator _iter370;
    for (_iter370 = this->prefixPaths.begin(); _iter370 != this->prefixPaths.end(); ++_iter370)
    {
      xfer += oprot->writeString((*_iter370));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter371;
    for (_iter371 = this->measurementsList.begin(); _iter371 != this->measurementsList.end(); ++_iter371)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter371).size()));
        std::vector<std::string> ::const_iterator _iter372;
        for (_iter372 = (*_iter371).begin(); _iter372 != (*_iter371).end(); ++_iter372)
        {
          xfer += oprot->writeString((*_iter372));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter373;
    for (_iter373 = this->valuesList.begin(); _iter373 != this->valuesList.end(); ++_iter373)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter373).size()));
        std::vector<std::string> ::const_iterator _iter374;
        for (_iter374 = (*_iter373).begin(); _iter374 != (*_iter373).end(); ++_iter374)
        {
          xfer += oprot->writeString((*_iter374));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter375;
    for (_iter375 = this->timestamps.begin(); _iter375 != this->timestamps.end(); ++_iter375)
    {
      xfer += oprot->writeI64((*_iter375));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isAligned) {
    xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isAligned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertStringRecordsReq &a, TSInsertStringRecordsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPaths, b.prefixPaths);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
  swap(a.isAligned, b.isAligned);
  swap(a.__isset, b.__isset);
}

TSInsertStringRecordsReq::TSInsertStringRecordsReq(const TSInsertStringRecordsReq& other376) {
  sessionId = other376.sessionId;
  prefixPaths = other376.prefixPaths;
  measurementsList = other376.measurementsList;
  valuesList = other376.valuesList;
  timestamps = other376.timestamps;
  isAligned = other376.isAligned;
  __isset = other376.__isset;
}
TSInsertStringRecordsReq& TSInsertStringRecordsReq::operator=(const TSInsertStringRecordsReq& other377) {
  sessionId = other377.sessionId;
  prefixPaths = other377.prefixPaths;
  measurementsList = other377.measurementsList;
  valuesList = other377.valuesList;
  timestamps = other377.timestamps;
  isAligned = other377.isAligned;
  __isset = other377.__isset;
  return *this;
}
void TSInsertStringRecordsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertStringRecordsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPaths=" << to_string(prefixPaths);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "isAligned="; (__isset.isAligned ? (out << to_string(isAligned)) : (out << "<null>"));
  out << ")";
}


TSDeleteDataReq::~TSDeleteDataReq() noexcept {
}


void TSDeleteDataReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSDeleteDataReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSDeleteDataReq::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void TSDeleteDataReq::__set_endTime(const int64_t val) {
  this->endTime = val;
}
std::ostream& operator<<(std::ostream& out, const TSDeleteDataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSDeleteDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_startTime = false;
  bool isset_endTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size378;
            ::apache::thrift::protocol::TType _etype381;
            xfer += iprot->readListBegin(_etype381, _size378);
            this->paths.resize(_size378);
            uint32_t _i382;
            for (_i382 = 0; _i382 < _size378; ++_i382)
            {
              xfer += iprot->readString(this->paths[_i382]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          isset_endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSDeleteDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSDeleteDataReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter383;
    for (_iter383 = this->paths.begin(); _iter383 != this->paths.end(); ++_iter383)
    {
      xfer += oprot->writeString((*_iter383));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->endTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSDeleteDataReq &a, TSDeleteDataReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
}

TSDeleteDataReq::TSDeleteDataReq(const TSDeleteDataReq& other384) {
  sessionId = other384.sessionId;
  paths = other384.paths;
  startTime = other384.startTime;
  endTime = other384.endTime;
}
TSDeleteDataReq& TSDeleteDataReq::operator=(const TSDeleteDataReq& other385) {
  sessionId = other385.sessionId;
  paths = other385.paths;
  startTime = other385.startTime;
  endTime = other385.endTime;
  return *this;
}
void TSDeleteDataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSDeleteDataReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "startTime=" << to_string(startTime);
  out << ", " << "endTime=" << to_string(endTime);
  out << ")";
}


TSCreateTimeseriesReq::~TSCreateTimeseriesReq() noexcept {
}


void TSCreateTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateTimeseriesReq::__set_path(const std::string& val) {
  this->path = val;
}

void TSCreateTimeseriesReq::__set_dataType(const int32_t val) {
  this->dataType = val;
}

void TSCreateTimeseriesReq::__set_encoding(const int32_t val) {
  this->encoding = val;
}

void TSCreateTimeseriesReq::__set_compressor(const int32_t val) {
  this->compressor = val;
}

void TSCreateTimeseriesReq::__set_props(const std::map<std::string, std::string> & val) {
  this->props = val;
__isset.props = true;
}

void TSCreateTimeseriesReq::__set_tags(const std::map<std::string, std::string> & val) {
  this->tags = val;
__isset.tags = true;
}

void TSCreateTimeseriesReq::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TSCreateTimeseriesReq::__set_measurementAlias(const std::string& val) {
  this->measurementAlias = val;
__isset.measurementAlias = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_path = false;
  bool isset_dataType = false;
  bool isset_encoding = false;
  bool isset_compressor = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dataType);
          isset_dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->encoding);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->compressor);
          isset_compressor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->props.clear();
            uint32_t _size386;
            ::apache::thrift::protocol::TType _ktype387;
            ::apache::thrift::protocol::TType _vtype388;
            xfer += iprot->readMapBegin(_ktype387, _vtype388, _size386);
            uint32_t _i390;
            for (_i390 = 0; _i390 < _size386; ++_i390)
            {
              std::string _key391;
              xfer += iprot->readString(_key391);
              std::string& _val392 = this->props[_key391];
              xfer += iprot->readString(_val392);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tags.clear();
            uint32_t _size393;
            ::apache::thrift::protocol::TType _ktype394;
            ::apache::thrift::protocol::TType _vtype395;
            xfer += iprot->readMapBegin(_ktype394, _vtype395, _size393);
            uint32_t _i397;
            for (_i397 = 0; _i397 < _size393; ++_i397)
            {
              std::string _key398;
              xfer += iprot->readString(_key398);
              std::string& _val399 = this->tags[_key398];
              xfer += iprot->readString(_val399);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _ktype401;
            ::apache::thrift::protocol::TType _vtype402;
            xfer += iprot->readMapBegin(_ktype401, _vtype402, _size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              std::string _key405;
              xfer += iprot->readString(_key405);
              std::string& _val406 = this->attributes[_key405];
              xfer += iprot->readString(_val406);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measurementAlias);
          this->__isset.measurementAlias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressor", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->compressor);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.props) {
    xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->props.size()));
      std::map<std::string, std::string> ::const_iterator _iter407;
      for (_iter407 = this->props.begin(); _iter407 != this->props.end(); ++_iter407)
      {
        xfer += oprot->writeString(_iter407->first);
        xfer += oprot->writeString(_iter407->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
      std::map<std::string, std::string> ::const_iterator _iter408;
      for (_iter408 = this->tags.begin(); _iter408 != this->tags.end(); ++_iter408)
      {
        xfer += oprot->writeString(_iter408->first);
        xfer += oprot->writeString(_iter408->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter409;
      for (_iter409 = this->attributes.begin(); _iter409 != this->attributes.end(); ++_iter409)
      {
        xfer += oprot->writeString(_iter409->first);
        xfer += oprot->writeString(_iter409->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurementAlias) {
    xfer += oprot->writeFieldBegin("measurementAlias", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->measurementAlias);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateTimeseriesReq &a, TSCreateTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.path, b.path);
  swap(a.dataType, b.dataType);
  swap(a.encoding, b.encoding);
  swap(a.compressor, b.compressor);
  swap(a.props, b.props);
  swap(a.tags, b.tags);
  swap(a.attributes, b.attributes);
  swap(a.measurementAlias, b.measurementAlias);
  swap(a.__isset, b.__isset);
}

TSCreateTimeseriesReq::TSCreateTimeseriesReq(const TSCreateTimeseriesReq& other410) {
  sessionId = other410.sessionId;
  path = other410.path;
  dataType = other410.dataType;
  encoding = other410.encoding;
  compressor = other410.compressor;
  props = other410.props;
  tags = other410.tags;
  attributes = other410.attributes;
  measurementAlias = other410.measurementAlias;
  __isset = other410.__isset;
}
TSCreateTimeseriesReq& TSCreateTimeseriesReq::operator=(const TSCreateTimeseriesReq& other411) {
  sessionId = other411.sessionId;
  path = other411.path;
  dataType = other411.dataType;
  encoding = other411.encoding;
  compressor = other411.compressor;
  props = other411.props;
  tags = other411.tags;
  attributes = other411.attributes;
  measurementAlias = other411.measurementAlias;
  __isset = other411.__isset;
  return *this;
}
void TSCreateTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "path=" << to_string(path);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "compressor=" << to_string(compressor);
  out << ", " << "props="; (__isset.props ? (out << to_string(props)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "measurementAlias="; (__isset.measurementAlias ? (out << to_string(measurementAlias)) : (out << "<null>"));
  out << ")";
}


TSCreateAlignedTimeseriesReq::~TSCreateAlignedTimeseriesReq() noexcept {
}


void TSCreateAlignedTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateAlignedTimeseriesReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSCreateAlignedTimeseriesReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSCreateAlignedTimeseriesReq::__set_dataTypes(const std::vector<int32_t> & val) {
  this->dataTypes = val;
}

void TSCreateAlignedTimeseriesReq::__set_encodings(const std::vector<int32_t> & val) {
  this->encodings = val;
}

void TSCreateAlignedTimeseriesReq::__set_compressors(const std::vector<int32_t> & val) {
  this->compressors = val;
}

void TSCreateAlignedTimeseriesReq::__set_measurementAlias(const std::vector<std::string> & val) {
  this->measurementAlias = val;
__isset.measurementAlias = true;
}

void TSCreateAlignedTimeseriesReq::__set_tagsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->tagsList = val;
__isset.tagsList = true;
}

void TSCreateAlignedTimeseriesReq::__set_attributesList(const std::vector<std::map<std::string, std::string> > & val) {
  this->attributesList = val;
__isset.attributesList = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateAlignedTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateAlignedTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_measurements = false;
  bool isset_dataTypes = false;
  bool isset_encodings = false;
  bool isset_compressors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size412;
            ::apache::thrift::protocol::TType _etype415;
            xfer += iprot->readListBegin(_etype415, _size412);
            this->measurements.resize(_size412);
            uint32_t _i416;
            for (_i416 = 0; _i416 < _size412; ++_i416)
            {
              xfer += iprot->readString(this->measurements[_i416]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypes.clear();
            uint32_t _size417;
            ::apache::thrift::protocol::TType _etype420;
            xfer += iprot->readListBegin(_etype420, _size417);
            this->dataTypes.resize(_size417);
            uint32_t _i421;
            for (_i421 = 0; _i421 < _size417; ++_i421)
            {
              xfer += iprot->readI32(this->dataTypes[_i421]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encodings.clear();
            uint32_t _size422;
            ::apache::thrift::protocol::TType _etype425;
            xfer += iprot->readListBegin(_etype425, _size422);
            this->encodings.resize(_size422);
            uint32_t _i426;
            for (_i426 = 0; _i426 < _size422; ++_i426)
            {
              xfer += iprot->readI32(this->encodings[_i426]);
            }
            xfer += iprot->readListEnd();
          }
          isset_encodings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compressors.clear();
            uint32_t _size427;
            ::apache::thrift::protocol::TType _etype430;
            xfer += iprot->readListBegin(_etype430, _size427);
            this->compressors.resize(_size427);
            uint32_t _i431;
            for (_i431 = 0; _i431 < _size427; ++_i431)
            {
              xfer += iprot->readI32(this->compressors[_i431]);
            }
            xfer += iprot->readListEnd();
          }
          isset_compressors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementAlias.clear();
            uint32_t _size432;
            ::apache::thrift::protocol::TType _etype435;
            xfer += iprot->readListBegin(_etype435, _size432);
            this->measurementAlias.resize(_size432);
            uint32_t _i436;
            for (_i436 = 0; _i436 < _size432; ++_i436)
            {
              xfer += iprot->readString(this->measurementAlias[_i436]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.measurementAlias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tagsList.clear();
            uint32_t _size437;
            ::apache::thrift::protocol::TType _etype440;
            xfer += iprot->readListBegin(_etype440, _size437);
            this->tagsList.resize(_size437);
            uint32_t _i441;
            for (_i441 = 0; _i441 < _size437; ++_i441)
            {
              {
                this->tagsList[_i441].clear();
                uint32_t _size442;
                ::apache::thrift::protocol::TType _ktype443;
                ::apache::thrift::protocol::TType _vtype444;
                xfer += iprot->readMapBegin(_ktype443, _vtype444, _size442);
                uint32_t _i446;
                for (_i446 = 0; _i446 < _size442; ++_i446)
                {
                  std::string _key447;
                  xfer += iprot->readString(_key447);
                  std::string& _val448 = this->tagsList[_i441][_key447];
                  xfer += iprot->readString(_val448);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tagsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributesList.clear();
            uint32_t _size449;
            ::apache::thrift::protocol::TType _etype452;
            xfer += iprot->readListBegin(_etype452, _size449);
            this->attributesList.resize(_size449);
            uint32_t _i453;
            for (_i453 = 0; _i453 < _size449; ++_i453)
            {
              {
                this->attributesList[_i453].clear();
                uint32_t _size454;
                ::apache::thrift::protocol::TType _ktype455;
                ::apache::thrift::protocol::TType _vtype456;
                xfer += iprot->readMapBegin(_ktype455, _vtype456, _size454);
                uint32_t _i458;
                for (_i458 = 0; _i458 < _size454; ++_i458)
                {
                  std::string _key459;
                  xfer += iprot->readString(_key459);
                  std::string& _val460 = this->attributesList[_i453][_key459];
                  xfer += iprot->readString(_val460);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataTypes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encodings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateAlignedTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateAlignedTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter461;
    for (_iter461 = this->measurements.begin(); _iter461 != this->measurements.end(); ++_iter461)
    {
      xfer += oprot->writeString((*_iter461));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataTypes", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dataTypes.size()));
    std::vector<int32_t> ::const_iterator _iter462;
    for (_iter462 = this->dataTypes.begin(); _iter462 != this->dataTypes.end(); ++_iter462)
    {
      xfer += oprot->writeI32((*_iter462));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encodings", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->encodings.size()));
    std::vector<int32_t> ::const_iterator _iter463;
    for (_iter463 = this->encodings.begin(); _iter463 != this->encodings.end(); ++_iter463)
    {
      xfer += oprot->writeI32((*_iter463));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressors", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->compressors.size()));
    std::vector<int32_t> ::const_iterator _iter464;
    for (_iter464 = this->compressors.begin(); _iter464 != this->compressors.end(); ++_iter464)
    {
      xfer += oprot->writeI32((*_iter464));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.measurementAlias) {
    xfer += oprot->writeFieldBegin("measurementAlias", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurementAlias.size()));
      std::vector<std::string> ::const_iterator _iter465;
      for (_iter465 = this->measurementAlias.begin(); _iter465 != this->measurementAlias.end(); ++_iter465)
      {
        xfer += oprot->writeString((*_iter465));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagsList) {
    xfer += oprot->writeFieldBegin("tagsList", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->tagsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter466;
      for (_iter466 = this->tagsList.begin(); _iter466 != this->tagsList.end(); ++_iter466)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter466).size()));
          std::map<std::string, std::string> ::const_iterator _iter467;
          for (_iter467 = (*_iter466).begin(); _iter467 != (*_iter466).end(); ++_iter467)
          {
            xfer += oprot->writeString(_iter467->first);
            xfer += oprot->writeString(_iter467->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributesList) {
    xfer += oprot->writeFieldBegin("attributesList", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->attributesList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter468;
      for (_iter468 = this->attributesList.begin(); _iter468 != this->attributesList.end(); ++_iter468)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter468).size()));
          std::map<std::string, std::string> ::const_iterator _iter469;
          for (_iter469 = (*_iter468).begin(); _iter469 != (*_iter468).end(); ++_iter469)
          {
            xfer += oprot->writeString(_iter469->first);
            xfer += oprot->writeString(_iter469->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateAlignedTimeseriesReq &a, TSCreateAlignedTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.measurements, b.measurements);
  swap(a.dataTypes, b.dataTypes);
  swap(a.encodings, b.encodings);
  swap(a.compressors, b.compressors);
  swap(a.measurementAlias, b.measurementAlias);
  swap(a.tagsList, b.tagsList);
  swap(a.attributesList, b.attributesList);
  swap(a.__isset, b.__isset);
}

TSCreateAlignedTimeseriesReq::TSCreateAlignedTimeseriesReq(const TSCreateAlignedTimeseriesReq& other470) {
  sessionId = other470.sessionId;
  prefixPath = other470.prefixPath;
  measurements = other470.measurements;
  dataTypes = other470.dataTypes;
  encodings = other470.encodings;
  compressors = other470.compressors;
  measurementAlias = other470.measurementAlias;
  tagsList = other470.tagsList;
  attributesList = other470.attributesList;
  __isset = other470.__isset;
}
TSCreateAlignedTimeseriesReq& TSCreateAlignedTimeseriesReq::operator=(const TSCreateAlignedTimeseriesReq& other471) {
  sessionId = other471.sessionId;
  prefixPath = other471.prefixPath;
  measurements = other471.measurements;
  dataTypes = other471.dataTypes;
  encodings = other471.encodings;
  compressors = other471.compressors;
  measurementAlias = other471.measurementAlias;
  tagsList = other471.tagsList;
  attributesList = other471.attributesList;
  __isset = other471.__isset;
  return *this;
}
void TSCreateAlignedTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateAlignedTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "dataTypes=" << to_string(dataTypes);
  out << ", " << "encodings=" << to_string(encodings);
  out << ", " << "compressors=" << to_string(compressors);
  out << ", " << "measurementAlias="; (__isset.measurementAlias ? (out << to_string(measurementAlias)) : (out << "<null>"));
  out << ", " << "tagsList="; (__isset.tagsList ? (out << to_string(tagsList)) : (out << "<null>"));
  out << ", " << "attributesList="; (__isset.attributesList ? (out << to_string(attributesList)) : (out << "<null>"));
  out << ")";
}


TSRawDataQueryReq::~TSRawDataQueryReq() noexcept {
}


void TSRawDataQueryReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSRawDataQueryReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSRawDataQueryReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSRawDataQueryReq::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void TSRawDataQueryReq::__set_endTime(const int64_t val) {
  this->endTime = val;
}

void TSRawDataQueryReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSRawDataQueryReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}

void TSRawDataQueryReq::__set_jdbcQuery(const bool val) {
  this->jdbcQuery = val;
__isset.jdbcQuery = true;
}

void TSRawDataQueryReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSRawDataQueryReq::__set_legalPathNodes(const bool val) {
  this->legalPathNodes = val;
__isset.legalPathNodes = true;
}
std::ostream& operator<<(std::ostream& out, const TSRawDataQueryReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSRawDataQueryReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_startTime = false;
  bool isset_endTime = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size472;
            ::apache::thrift::protocol::TType _etype475;
            xfer += iprot->readListBegin(_etype475, _size472);
            this->paths.resize(_size472);
            uint32_t _i476;
            for (_i476 = 0; _i476 < _size472; ++_i476)
            {
              xfer += iprot->readString(this->paths[_i476]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          isset_endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->jdbcQuery);
          this->__isset.jdbcQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->legalPathNodes);
          this->__isset.legalPathNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSRawDataQueryReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSRawDataQueryReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter477;
    for (_iter477 = this->paths.begin(); _iter477 != this->paths.end(); ++_iter477)
    {
      xfer += oprot->writeString((*_iter477));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->endTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jdbcQuery) {
    xfer += oprot->writeFieldBegin("jdbcQuery", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->jdbcQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legalPathNodes) {
    xfer += oprot->writeFieldBegin("legalPathNodes", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->legalPathNodes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSRawDataQueryReq &a, TSRawDataQueryReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.fetchSize, b.fetchSize);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
  swap(a.statementId, b.statementId);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.jdbcQuery, b.jdbcQuery);
  swap(a.timeout, b.timeout);
  swap(a.legalPathNodes, b.legalPathNodes);
  swap(a.__isset, b.__isset);
}

TSRawDataQueryReq::TSRawDataQueryReq(const TSRawDataQueryReq& other478) {
  sessionId = other478.sessionId;
  paths = other478.paths;
  fetchSize = other478.fetchSize;
  startTime = other478.startTime;
  endTime = other478.endTime;
  statementId = other478.statementId;
  enableRedirectQuery = other478.enableRedirectQuery;
  jdbcQuery = other478.jdbcQuery;
  timeout = other478.timeout;
  legalPathNodes = other478.legalPathNodes;
  __isset = other478.__isset;
}
TSRawDataQueryReq& TSRawDataQueryReq::operator=(const TSRawDataQueryReq& other479) {
  sessionId = other479.sessionId;
  paths = other479.paths;
  fetchSize = other479.fetchSize;
  startTime = other479.startTime;
  endTime = other479.endTime;
  statementId = other479.statementId;
  enableRedirectQuery = other479.enableRedirectQuery;
  jdbcQuery = other479.jdbcQuery;
  timeout = other479.timeout;
  legalPathNodes = other479.legalPathNodes;
  __isset = other479.__isset;
  return *this;
}
void TSRawDataQueryReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSRawDataQueryReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "startTime=" << to_string(startTime);
  out << ", " << "endTime=" << to_string(endTime);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ", " << "jdbcQuery="; (__isset.jdbcQuery ? (out << to_string(jdbcQuery)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "legalPathNodes="; (__isset.legalPathNodes ? (out << to_string(legalPathNodes)) : (out << "<null>"));
  out << ")";
}


TSLastDataQueryReq::~TSLastDataQueryReq() noexcept {
}


void TSLastDataQueryReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSLastDataQueryReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSLastDataQueryReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSLastDataQueryReq::__set_time(const int64_t val) {
  this->time = val;
}

void TSLastDataQueryReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSLastDataQueryReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}

void TSLastDataQueryReq::__set_jdbcQuery(const bool val) {
  this->jdbcQuery = val;
__isset.jdbcQuery = true;
}

void TSLastDataQueryReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSLastDataQueryReq::__set_legalPathNodes(const bool val) {
  this->legalPathNodes = val;
__isset.legalPathNodes = true;
}
std::ostream& operator<<(std::ostream& out, const TSLastDataQueryReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSLastDataQueryReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_time = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size480;
            ::apache::thrift::protocol::TType _etype483;
            xfer += iprot->readListBegin(_etype483, _size480);
            this->paths.resize(_size480);
            uint32_t _i484;
            for (_i484 = 0; _i484 < _size480; ++_i484)
            {
              xfer += iprot->readString(this->paths[_i484]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          isset_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->jdbcQuery);
          this->__isset.jdbcQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->legalPathNodes);
          this->__isset.legalPathNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSLastDataQueryReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSLastDataQueryReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter485;
    for (_iter485 = this->paths.begin(); _iter485 != this->paths.end(); ++_iter485)
    {
      xfer += oprot->writeString((*_iter485));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jdbcQuery) {
    xfer += oprot->writeFieldBegin("jdbcQuery", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->jdbcQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legalPathNodes) {
    xfer += oprot->writeFieldBegin("legalPathNodes", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->legalPathNodes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSLastDataQueryReq &a, TSLastDataQueryReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.fetchSize, b.fetchSize);
  swap(a.time, b.time);
  swap(a.statementId, b.statementId);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.jdbcQuery, b.jdbcQuery);
  swap(a.timeout, b.timeout);
  swap(a.legalPathNodes, b.legalPathNodes);
  swap(a.__isset, b.__isset);
}

TSLastDataQueryReq::TSLastDataQueryReq(const TSLastDataQueryReq& other486) {
  sessionId = other486.sessionId;
  paths = other486.paths;
  fetchSize = other486.fetchSize;
  time = other486.time;
  statementId = other486.statementId;
  enableRedirectQuery = other486.enableRedirectQuery;
  jdbcQuery = other486.jdbcQuery;
  timeout = other486.timeout;
  legalPathNodes = other486.legalPathNodes;
  __isset = other486.__isset;
}
TSLastDataQueryReq& TSLastDataQueryReq::operator=(const TSLastDataQueryReq& other487) {
  sessionId = other487.sessionId;
  paths = other487.paths;
  fetchSize = other487.fetchSize;
  time = other487.time;
  statementId = other487.statementId;
  enableRedirectQuery = other487.enableRedirectQuery;
  jdbcQuery = other487.jdbcQuery;
  timeout = other487.timeout;
  legalPathNodes = other487.legalPathNodes;
  __isset = other487.__isset;
  return *this;
}
void TSLastDataQueryReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSLastDataQueryReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "time=" << to_string(time);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ", " << "jdbcQuery="; (__isset.jdbcQuery ? (out << to_string(jdbcQuery)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "legalPathNodes="; (__isset.legalPathNodes ? (out << to_string(legalPathNodes)) : (out << "<null>"));
  out << ")";
}


TSFastLastDataQueryForOnePrefixPathReq::~TSFastLastDataQueryForOnePrefixPathReq() noexcept {
}


void TSFastLastDataQueryForOnePrefixPathReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFastLastDataQueryForOnePrefixPathReq::__set_prefixes(const std::vector<std::string> & val) {
  this->prefixes = val;
}

void TSFastLastDataQueryForOnePrefixPathReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSFastLastDataQueryForOnePrefixPathReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSFastLastDataQueryForOnePrefixPathReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}

void TSFastLastDataQueryForOnePrefixPathReq::__set_jdbcQuery(const bool val) {
  this->jdbcQuery = val;
__isset.jdbcQuery = true;
}

void TSFastLastDataQueryForOnePrefixPathReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}
std::ostream& operator<<(std::ostream& out, const TSFastLastDataQueryForOnePrefixPathReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFastLastDataQueryForOnePrefixPathReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixes = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->prefixes.clear();
            uint32_t _size488;
            ::apache::thrift::protocol::TType _etype491;
            xfer += iprot->readListBegin(_etype491, _size488);
            this->prefixes.resize(_size488);
            uint32_t _i492;
            for (_i492 = 0; _i492 < _size488; ++_i492)
            {
              xfer += iprot->readString(this->prefixes[_i492]);
            }
            xfer += iprot->readListEnd();
          }
          isset_prefixes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->jdbcQuery);
          this->__isset.jdbcQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFastLastDataQueryForOnePrefixPathReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFastLastDataQueryForOnePrefixPathReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->prefixes.size()));
    std::vector<std::string> ::const_iterator _iter493;
    for (_iter493 = this->prefixes.begin(); _iter493 != this->prefixes.end(); ++_iter493)
    {
      xfer += oprot->writeString((*_iter493));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jdbcQuery) {
    xfer += oprot->writeFieldBegin("jdbcQuery", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->jdbcQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFastLastDataQueryForOnePrefixPathReq &a, TSFastLastDataQueryForOnePrefixPathReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixes, b.prefixes);
  swap(a.fetchSize, b.fetchSize);
  swap(a.statementId, b.statementId);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.jdbcQuery, b.jdbcQuery);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

TSFastLastDataQueryForOnePrefixPathReq::TSFastLastDataQueryForOnePrefixPathReq(const TSFastLastDataQueryForOnePrefixPathReq& other494) {
  sessionId = other494.sessionId;
  prefixes = other494.prefixes;
  fetchSize = other494.fetchSize;
  statementId = other494.statementId;
  enableRedirectQuery = other494.enableRedirectQuery;
  jdbcQuery = other494.jdbcQuery;
  timeout = other494.timeout;
  __isset = other494.__isset;
}
TSFastLastDataQueryForOnePrefixPathReq& TSFastLastDataQueryForOnePrefixPathReq::operator=(const TSFastLastDataQueryForOnePrefixPathReq& other495) {
  sessionId = other495.sessionId;
  prefixes = other495.prefixes;
  fetchSize = other495.fetchSize;
  statementId = other495.statementId;
  enableRedirectQuery = other495.enableRedirectQuery;
  jdbcQuery = other495.jdbcQuery;
  timeout = other495.timeout;
  __isset = other495.__isset;
  return *this;
}
void TSFastLastDataQueryForOnePrefixPathReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFastLastDataQueryForOnePrefixPathReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixes=" << to_string(prefixes);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ", " << "jdbcQuery="; (__isset.jdbcQuery ? (out << to_string(jdbcQuery)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


TSFastLastDataQueryForOneDeviceReq::~TSFastLastDataQueryForOneDeviceReq() noexcept {
}


void TSFastLastDataQueryForOneDeviceReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFastLastDataQueryForOneDeviceReq::__set_db(const std::string& val) {
  this->db = val;
}

void TSFastLastDataQueryForOneDeviceReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSFastLastDataQueryForOneDeviceReq::__set_sensors(const std::vector<std::string> & val) {
  this->sensors = val;
}

void TSFastLastDataQueryForOneDeviceReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSFastLastDataQueryForOneDeviceReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSFastLastDataQueryForOneDeviceReq::__set_enableRedirectQuery(const bool val) {
  this->enableRedirectQuery = val;
__isset.enableRedirectQuery = true;
}

void TSFastLastDataQueryForOneDeviceReq::__set_jdbcQuery(const bool val) {
  this->jdbcQuery = val;
__isset.jdbcQuery = true;
}

void TSFastLastDataQueryForOneDeviceReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSFastLastDataQueryForOneDeviceReq::__set_legalPathNodes(const bool val) {
  this->legalPathNodes = val;
__isset.legalPathNodes = true;
}
std::ostream& operator<<(std::ostream& out, const TSFastLastDataQueryForOneDeviceReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFastLastDataQueryForOneDeviceReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_db = false;
  bool isset_deviceId = false;
  bool isset_sensors = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sensors.clear();
            uint32_t _size496;
            ::apache::thrift::protocol::TType _etype499;
            xfer += iprot->readListBegin(_etype499, _size496);
            this->sensors.resize(_size496);
            uint32_t _i500;
            for (_i500 = 0; _i500 < _size496; ++_i500)
            {
              xfer += iprot->readString(this->sensors[_i500]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sensors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableRedirectQuery);
          this->__isset.enableRedirectQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->jdbcQuery);
          this->__isset.jdbcQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->legalPathNodes);
          this->__isset.legalPathNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sensors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFastLastDataQueryForOneDeviceReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFastLastDataQueryForOneDeviceReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sensors", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sensors.size()));
    std::vector<std::string> ::const_iterator _iter501;
    for (_iter501 = this->sensors.begin(); _iter501 != this->sensors.end(); ++_iter501)
    {
      xfer += oprot->writeString((*_iter501));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enableRedirectQuery) {
    xfer += oprot->writeFieldBegin("enableRedirectQuery", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->enableRedirectQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jdbcQuery) {
    xfer += oprot->writeFieldBegin("jdbcQuery", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->jdbcQuery);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legalPathNodes) {
    xfer += oprot->writeFieldBegin("legalPathNodes", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->legalPathNodes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFastLastDataQueryForOneDeviceReq &a, TSFastLastDataQueryForOneDeviceReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.db, b.db);
  swap(a.deviceId, b.deviceId);
  swap(a.sensors, b.sensors);
  swap(a.fetchSize, b.fetchSize);
  swap(a.statementId, b.statementId);
  swap(a.enableRedirectQuery, b.enableRedirectQuery);
  swap(a.jdbcQuery, b.jdbcQuery);
  swap(a.timeout, b.timeout);
  swap(a.legalPathNodes, b.legalPathNodes);
  swap(a.__isset, b.__isset);
}

TSFastLastDataQueryForOneDeviceReq::TSFastLastDataQueryForOneDeviceReq(const TSFastLastDataQueryForOneDeviceReq& other502) {
  sessionId = other502.sessionId;
  db = other502.db;
  deviceId = other502.deviceId;
  sensors = other502.sensors;
  fetchSize = other502.fetchSize;
  statementId = other502.statementId;
  enableRedirectQuery = other502.enableRedirectQuery;
  jdbcQuery = other502.jdbcQuery;
  timeout = other502.timeout;
  legalPathNodes = other502.legalPathNodes;
  __isset = other502.__isset;
}
TSFastLastDataQueryForOneDeviceReq& TSFastLastDataQueryForOneDeviceReq::operator=(const TSFastLastDataQueryForOneDeviceReq& other503) {
  sessionId = other503.sessionId;
  db = other503.db;
  deviceId = other503.deviceId;
  sensors = other503.sensors;
  fetchSize = other503.fetchSize;
  statementId = other503.statementId;
  enableRedirectQuery = other503.enableRedirectQuery;
  jdbcQuery = other503.jdbcQuery;
  timeout = other503.timeout;
  legalPathNodes = other503.legalPathNodes;
  __isset = other503.__isset;
  return *this;
}
void TSFastLastDataQueryForOneDeviceReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFastLastDataQueryForOneDeviceReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "db=" << to_string(db);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "sensors=" << to_string(sensors);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "enableRedirectQuery="; (__isset.enableRedirectQuery ? (out << to_string(enableRedirectQuery)) : (out << "<null>"));
  out << ", " << "jdbcQuery="; (__isset.jdbcQuery ? (out << to_string(jdbcQuery)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "legalPathNodes="; (__isset.legalPathNodes ? (out << to_string(legalPathNodes)) : (out << "<null>"));
  out << ")";
}


TSAggregationQueryReq::~TSAggregationQueryReq() noexcept {
}


void TSAggregationQueryReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSAggregationQueryReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSAggregationQueryReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSAggregationQueryReq::__set_aggregations(const std::vector< ::TAggregationType::type> & val) {
  this->aggregations = val;
}

void TSAggregationQueryReq::__set_startTime(const int64_t val) {
  this->startTime = val;
__isset.startTime = true;
}

void TSAggregationQueryReq::__set_endTime(const int64_t val) {
  this->endTime = val;
__isset.endTime = true;
}

void TSAggregationQueryReq::__set_interval(const int64_t val) {
  this->interval = val;
__isset.interval = true;
}

void TSAggregationQueryReq::__set_slidingStep(const int64_t val) {
  this->slidingStep = val;
__isset.slidingStep = true;
}

void TSAggregationQueryReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSAggregationQueryReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void TSAggregationQueryReq::__set_legalPathNodes(const bool val) {
  this->legalPathNodes = val;
__isset.legalPathNodes = true;
}
std::ostream& operator<<(std::ostream& out, const TSAggregationQueryReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSAggregationQueryReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statementId = false;
  bool isset_paths = false;
  bool isset_aggregations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size504;
            ::apache::thrift::protocol::TType _etype507;
            xfer += iprot->readListBegin(_etype507, _size504);
            this->paths.resize(_size504);
            uint32_t _i508;
            for (_i508 = 0; _i508 < _size504; ++_i508)
            {
              xfer += iprot->readString(this->paths[_i508]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregations.clear();
            uint32_t _size509;
            ::apache::thrift::protocol::TType _etype512;
            xfer += iprot->readListBegin(_etype512, _size509);
            this->aggregations.resize(_size509);
            uint32_t _i513;
            for (_i513 = 0; _i513 < _size509; ++_i513)
            {
              int32_t ecast514;
              xfer += iprot->readI32(ecast514);
              this->aggregations[_i513] = ( ::TAggregationType::type)ecast514;
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          this->__isset.endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slidingStep);
          this->__isset.slidingStep = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->legalPathNodes);
          this->__isset.legalPathNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSAggregationQueryReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSAggregationQueryReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter515;
    for (_iter515 = this->paths.begin(); _iter515 != this->paths.end(); ++_iter515)
    {
      xfer += oprot->writeString((*_iter515));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->aggregations.size()));
    std::vector< ::TAggregationType::type> ::const_iterator _iter516;
    for (_iter516 = this->aggregations.begin(); _iter516 != this->aggregations.end(); ++_iter516)
    {
      xfer += oprot->writeI32((int32_t)(*_iter516));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startTime) {
    xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->startTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endTime) {
    xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->endTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slidingStep) {
    xfer += oprot->writeFieldBegin("slidingStep", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->slidingStep);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legalPathNodes) {
    xfer += oprot->writeFieldBegin("legalPathNodes", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->legalPathNodes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSAggregationQueryReq &a, TSAggregationQueryReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statementId, b.statementId);
  swap(a.paths, b.paths);
  swap(a.aggregations, b.aggregations);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
  swap(a.interval, b.interval);
  swap(a.slidingStep, b.slidingStep);
  swap(a.fetchSize, b.fetchSize);
  swap(a.timeout, b.timeout);
  swap(a.legalPathNodes, b.legalPathNodes);
  swap(a.__isset, b.__isset);
}

TSAggregationQueryReq::TSAggregationQueryReq(const TSAggregationQueryReq& other517) {
  sessionId = other517.sessionId;
  statementId = other517.statementId;
  paths = other517.paths;
  aggregations = other517.aggregations;
  startTime = other517.startTime;
  endTime = other517.endTime;
  interval = other517.interval;
  slidingStep = other517.slidingStep;
  fetchSize = other517.fetchSize;
  timeout = other517.timeout;
  legalPathNodes = other517.legalPathNodes;
  __isset = other517.__isset;
}
TSAggregationQueryReq& TSAggregationQueryReq::operator=(const TSAggregationQueryReq& other518) {
  sessionId = other518.sessionId;
  statementId = other518.statementId;
  paths = other518.paths;
  aggregations = other518.aggregations;
  startTime = other518.startTime;
  endTime = other518.endTime;
  interval = other518.interval;
  slidingStep = other518.slidingStep;
  fetchSize = other518.fetchSize;
  timeout = other518.timeout;
  legalPathNodes = other518.legalPathNodes;
  __isset = other518.__isset;
  return *this;
}
void TSAggregationQueryReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSAggregationQueryReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "aggregations=" << to_string(aggregations);
  out << ", " << "startTime="; (__isset.startTime ? (out << to_string(startTime)) : (out << "<null>"));
  out << ", " << "endTime="; (__isset.endTime ? (out << to_string(endTime)) : (out << "<null>"));
  out << ", " << "interval="; (__isset.interval ? (out << to_string(interval)) : (out << "<null>"));
  out << ", " << "slidingStep="; (__isset.slidingStep ? (out << to_string(slidingStep)) : (out << "<null>"));
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "legalPathNodes="; (__isset.legalPathNodes ? (out << to_string(legalPathNodes)) : (out << "<null>"));
  out << ")";
}


TSGroupByQueryIntervalReq::~TSGroupByQueryIntervalReq() noexcept {
}


void TSGroupByQueryIntervalReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSGroupByQueryIntervalReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSGroupByQueryIntervalReq::__set_device(const std::string& val) {
  this->device = val;
}

void TSGroupByQueryIntervalReq::__set_measurement(const std::string& val) {
  this->measurement = val;
}

void TSGroupByQueryIntervalReq::__set_dataType(const int32_t val) {
  this->dataType = val;
}

void TSGroupByQueryIntervalReq::__set_aggregationType(const  ::TAggregationType::type val) {
  this->aggregationType = val;
}

void TSGroupByQueryIntervalReq::__set_database(const std::string& val) {
  this->database = val;
__isset.database = true;
}

void TSGroupByQueryIntervalReq::__set_startTime(const int64_t val) {
  this->startTime = val;
__isset.startTime = true;
}

void TSGroupByQueryIntervalReq::__set_endTime(const int64_t val) {
  this->endTime = val;
__isset.endTime = true;
}

void TSGroupByQueryIntervalReq::__set_interval(const int64_t val) {
  this->interval = val;
__isset.interval = true;
}

void TSGroupByQueryIntervalReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}

void TSGroupByQueryIntervalReq::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}
std::ostream& operator<<(std::ostream& out, const TSGroupByQueryIntervalReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGroupByQueryIntervalReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statementId = false;
  bool isset_device = false;
  bool isset_measurement = false;
  bool isset_dataType = false;
  bool isset_aggregationType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->device);
          isset_device = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measurement);
          isset_measurement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dataType);
          isset_dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast519;
          xfer += iprot->readI32(ecast519);
          this->aggregationType = ( ::TAggregationType::type)ecast519;
          isset_aggregationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          this->__isset.database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          this->__isset.endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_device)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregationType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGroupByQueryIntervalReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGroupByQueryIntervalReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("device", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->device);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurement", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->measurement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregationType", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->aggregationType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.database) {
    xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->database);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startTime) {
    xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->startTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endTime) {
    xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->endTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGroupByQueryIntervalReq &a, TSGroupByQueryIntervalReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statementId, b.statementId);
  swap(a.device, b.device);
  swap(a.measurement, b.measurement);
  swap(a.dataType, b.dataType);
  swap(a.aggregationType, b.aggregationType);
  swap(a.database, b.database);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
  swap(a.interval, b.interval);
  swap(a.fetchSize, b.fetchSize);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

TSGroupByQueryIntervalReq::TSGroupByQueryIntervalReq(const TSGroupByQueryIntervalReq& other520) {
  sessionId = other520.sessionId;
  statementId = other520.statementId;
  device = other520.device;
  measurement = other520.measurement;
  dataType = other520.dataType;
  aggregationType = other520.aggregationType;
  database = other520.database;
  startTime = other520.startTime;
  endTime = other520.endTime;
  interval = other520.interval;
  fetchSize = other520.fetchSize;
  timeout = other520.timeout;
  __isset = other520.__isset;
}
TSGroupByQueryIntervalReq& TSGroupByQueryIntervalReq::operator=(const TSGroupByQueryIntervalReq& other521) {
  sessionId = other521.sessionId;
  statementId = other521.statementId;
  device = other521.device;
  measurement = other521.measurement;
  dataType = other521.dataType;
  aggregationType = other521.aggregationType;
  database = other521.database;
  startTime = other521.startTime;
  endTime = other521.endTime;
  interval = other521.interval;
  fetchSize = other521.fetchSize;
  timeout = other521.timeout;
  __isset = other521.__isset;
  return *this;
}
void TSGroupByQueryIntervalReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGroupByQueryIntervalReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "device=" << to_string(device);
  out << ", " << "measurement=" << to_string(measurement);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "aggregationType=" << to_string(aggregationType);
  out << ", " << "database="; (__isset.database ? (out << to_string(database)) : (out << "<null>"));
  out << ", " << "startTime="; (__isset.startTime ? (out << to_string(startTime)) : (out << "<null>"));
  out << ", " << "endTime="; (__isset.endTime ? (out << to_string(endTime)) : (out << "<null>"));
  out << ", " << "interval="; (__isset.interval ? (out << to_string(interval)) : (out << "<null>"));
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


TSCreateMultiTimeseriesReq::~TSCreateMultiTimeseriesReq() noexcept {
}


void TSCreateMultiTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateMultiTimeseriesReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSCreateMultiTimeseriesReq::__set_dataTypes(const std::vector<int32_t> & val) {
  this->dataTypes = val;
}

void TSCreateMultiTimeseriesReq::__set_encodings(const std::vector<int32_t> & val) {
  this->encodings = val;
}

void TSCreateMultiTimeseriesReq::__set_compressors(const std::vector<int32_t> & val) {
  this->compressors = val;
}

void TSCreateMultiTimeseriesReq::__set_propsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->propsList = val;
__isset.propsList = true;
}

void TSCreateMultiTimeseriesReq::__set_tagsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->tagsList = val;
__isset.tagsList = true;
}

void TSCreateMultiTimeseriesReq::__set_attributesList(const std::vector<std::map<std::string, std::string> > & val) {
  this->attributesList = val;
__isset.attributesList = true;
}

void TSCreateMultiTimeseriesReq::__set_measurementAliasList(const std::vector<std::string> & val) {
  this->measurementAliasList = val;
__isset.measurementAliasList = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateMultiTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateMultiTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_dataTypes = false;
  bool isset_encodings = false;
  bool isset_compressors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size522;
            ::apache::thrift::protocol::TType _etype525;
            xfer += iprot->readListBegin(_etype525, _size522);
            this->paths.resize(_size522);
            uint32_t _i526;
            for (_i526 = 0; _i526 < _size522; ++_i526)
            {
              xfer += iprot->readString(this->paths[_i526]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypes.clear();
            uint32_t _size527;
            ::apache::thrift::protocol::TType _etype530;
            xfer += iprot->readListBegin(_etype530, _size527);
            this->dataTypes.resize(_size527);
            uint32_t _i531;
            for (_i531 = 0; _i531 < _size527; ++_i531)
            {
              xfer += iprot->readI32(this->dataTypes[_i531]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encodings.clear();
            uint32_t _size532;
            ::apache::thrift::protocol::TType _etype535;
            xfer += iprot->readListBegin(_etype535, _size532);
            this->encodings.resize(_size532);
            uint32_t _i536;
            for (_i536 = 0; _i536 < _size532; ++_i536)
            {
              xfer += iprot->readI32(this->encodings[_i536]);
            }
            xfer += iprot->readListEnd();
          }
          isset_encodings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compressors.clear();
            uint32_t _size537;
            ::apache::thrift::protocol::TType _etype540;
            xfer += iprot->readListBegin(_etype540, _size537);
            this->compressors.resize(_size537);
            uint32_t _i541;
            for (_i541 = 0; _i541 < _size537; ++_i541)
            {
              xfer += iprot->readI32(this->compressors[_i541]);
            }
            xfer += iprot->readListEnd();
          }
          isset_compressors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->propsList.clear();
            uint32_t _size542;
            ::apache::thrift::protocol::TType _etype545;
            xfer += iprot->readListBegin(_etype545, _size542);
            this->propsList.resize(_size542);
            uint32_t _i546;
            for (_i546 = 0; _i546 < _size542; ++_i546)
            {
              {
                this->propsList[_i546].clear();
                uint32_t _size547;
                ::apache::thrift::protocol::TType _ktype548;
                ::apache::thrift::protocol::TType _vtype549;
                xfer += iprot->readMapBegin(_ktype548, _vtype549, _size547);
                uint32_t _i551;
                for (_i551 = 0; _i551 < _size547; ++_i551)
                {
                  std::string _key552;
                  xfer += iprot->readString(_key552);
                  std::string& _val553 = this->propsList[_i546][_key552];
                  xfer += iprot->readString(_val553);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.propsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tagsList.clear();
            uint32_t _size554;
            ::apache::thrift::protocol::TType _etype557;
            xfer += iprot->readListBegin(_etype557, _size554);
            this->tagsList.resize(_size554);
            uint32_t _i558;
            for (_i558 = 0; _i558 < _size554; ++_i558)
            {
              {
                this->tagsList[_i558].clear();
                uint32_t _size559;
                ::apache::thrift::protocol::TType _ktype560;
                ::apache::thrift::protocol::TType _vtype561;
                xfer += iprot->readMapBegin(_ktype560, _vtype561, _size559);
                uint32_t _i563;
                for (_i563 = 0; _i563 < _size559; ++_i563)
                {
                  std::string _key564;
                  xfer += iprot->readString(_key564);
                  std::string& _val565 = this->tagsList[_i558][_key564];
                  xfer += iprot->readString(_val565);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tagsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributesList.clear();
            uint32_t _size566;
            ::apache::thrift::protocol::TType _etype569;
            xfer += iprot->readListBegin(_etype569, _size566);
            this->attributesList.resize(_size566);
            uint32_t _i570;
            for (_i570 = 0; _i570 < _size566; ++_i570)
            {
              {
                this->attributesList[_i570].clear();
                uint32_t _size571;
                ::apache::thrift::protocol::TType _ktype572;
                ::apache::thrift::protocol::TType _vtype573;
                xfer += iprot->readMapBegin(_ktype572, _vtype573, _size571);
                uint32_t _i575;
                for (_i575 = 0; _i575 < _size571; ++_i575)
                {
                  std::string _key576;
                  xfer += iprot->readString(_key576);
                  std::string& _val577 = this->attributesList[_i570][_key576];
                  xfer += iprot->readString(_val577);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementAliasList.clear();
            uint32_t _size578;
            ::apache::thrift::protocol::TType _etype581;
            xfer += iprot->readListBegin(_etype581, _size578);
            this->measurementAliasList.resize(_size578);
            uint32_t _i582;
            for (_i582 = 0; _i582 < _size578; ++_i582)
            {
              xfer += iprot->readString(this->measurementAliasList[_i582]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.measurementAliasList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataTypes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encodings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateMultiTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateMultiTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter583;
    for (_iter583 = this->paths.begin(); _iter583 != this->paths.end(); ++_iter583)
    {
      xfer += oprot->writeString((*_iter583));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataTypes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dataTypes.size()));
    std::vector<int32_t> ::const_iterator _iter584;
    for (_iter584 = this->dataTypes.begin(); _iter584 != this->dataTypes.end(); ++_iter584)
    {
      xfer += oprot->writeI32((*_iter584));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encodings", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->encodings.size()));
    std::vector<int32_t> ::const_iterator _iter585;
    for (_iter585 = this->encodings.begin(); _iter585 != this->encodings.end(); ++_iter585)
    {
      xfer += oprot->writeI32((*_iter585));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressors", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->compressors.size()));
    std::vector<int32_t> ::const_iterator _iter586;
    for (_iter586 = this->compressors.begin(); _iter586 != this->compressors.end(); ++_iter586)
    {
      xfer += oprot->writeI32((*_iter586));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.propsList) {
    xfer += oprot->writeFieldBegin("propsList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->propsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter587;
      for (_iter587 = this->propsList.begin(); _iter587 != this->propsList.end(); ++_iter587)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter587).size()));
          std::map<std::string, std::string> ::const_iterator _iter588;
          for (_iter588 = (*_iter587).begin(); _iter588 != (*_iter587).end(); ++_iter588)
          {
            xfer += oprot->writeString(_iter588->first);
            xfer += oprot->writeString(_iter588->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagsList) {
    xfer += oprot->writeFieldBegin("tagsList", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->tagsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter589;
      for (_iter589 = this->tagsList.begin(); _iter589 != this->tagsList.end(); ++_iter589)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter589).size()));
          std::map<std::string, std::string> ::const_iterator _iter590;
          for (_iter590 = (*_iter589).begin(); _iter590 != (*_iter589).end(); ++_iter590)
          {
            xfer += oprot->writeString(_iter590->first);
            xfer += oprot->writeString(_iter590->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributesList) {
    xfer += oprot->writeFieldBegin("attributesList", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->attributesList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter591;
      for (_iter591 = this->attributesList.begin(); _iter591 != this->attributesList.end(); ++_iter591)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter591).size()));
          std::map<std::string, std::string> ::const_iterator _iter592;
          for (_iter592 = (*_iter591).begin(); _iter592 != (*_iter591).end(); ++_iter592)
          {
            xfer += oprot->writeString(_iter592->first);
            xfer += oprot->writeString(_iter592->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurementAliasList) {
    xfer += oprot->writeFieldBegin("measurementAliasList", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurementAliasList.size()));
      std::vector<std::string> ::const_iterator _iter593;
      for (_iter593 = this->measurementAliasList.begin(); _iter593 != this->measurementAliasList.end(); ++_iter593)
      {
        xfer += oprot->writeString((*_iter593));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateMultiTimeseriesReq &a, TSCreateMultiTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.dataTypes, b.dataTypes);
  swap(a.encodings, b.encodings);
  swap(a.compressors, b.compressors);
  swap(a.propsList, b.propsList);
  swap(a.tagsList, b.tagsList);
  swap(a.attributesList, b.attributesList);
  swap(a.measurementAliasList, b.measurementAliasList);
  swap(a.__isset, b.__isset);
}

TSCreateMultiTimeseriesReq::TSCreateMultiTimeseriesReq(const TSCreateMultiTimeseriesReq& other594) {
  sessionId = other594.sessionId;
  paths = other594.paths;
  dataTypes = other594.dataTypes;
  encodings = other594.encodings;
  compressors = other594.compressors;
  propsList = other594.propsList;
  tagsList = other594.tagsList;
  attributesList = other594.attributesList;
  measurementAliasList = other594.measurementAliasList;
  __isset = other594.__isset;
}
TSCreateMultiTimeseriesReq& TSCreateMultiTimeseriesReq::operator=(const TSCreateMultiTimeseriesReq& other595) {
  sessionId = other595.sessionId;
  paths = other595.paths;
  dataTypes = other595.dataTypes;
  encodings = other595.encodings;
  compressors = other595.compressors;
  propsList = other595.propsList;
  tagsList = other595.tagsList;
  attributesList = other595.attributesList;
  measurementAliasList = other595.measurementAliasList;
  __isset = other595.__isset;
  return *this;
}
void TSCreateMultiTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateMultiTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "dataTypes=" << to_string(dataTypes);
  out << ", " << "encodings=" << to_string(encodings);
  out << ", " << "compressors=" << to_string(compressors);
  out << ", " << "propsList="; (__isset.propsList ? (out << to_string(propsList)) : (out << "<null>"));
  out << ", " << "tagsList="; (__isset.tagsList ? (out << to_string(tagsList)) : (out << "<null>"));
  out << ", " << "attributesList="; (__isset.attributesList ? (out << to_string(attributesList)) : (out << "<null>"));
  out << ", " << "measurementAliasList="; (__isset.measurementAliasList ? (out << to_string(measurementAliasList)) : (out << "<null>"));
  out << ")";
}


ServerProperties::~ServerProperties() noexcept {
}


void ServerProperties::__set_version(const std::string& val) {
  this->version = val;
}

void ServerProperties::__set_supportedTimeAggregationOperations(const std::vector<std::string> & val) {
  this->supportedTimeAggregationOperations = val;
}

void ServerProperties::__set_timestampPrecision(const std::string& val) {
  this->timestampPrecision = val;
}

void ServerProperties::__set_maxConcurrentClientNum(const int32_t val) {
  this->maxConcurrentClientNum = val;
}

void ServerProperties::__set_thriftMaxFrameSize(const int32_t val) {
  this->thriftMaxFrameSize = val;
__isset.thriftMaxFrameSize = true;
}

void ServerProperties::__set_isReadOnly(const bool val) {
  this->isReadOnly = val;
__isset.isReadOnly = true;
}

void ServerProperties::__set_buildInfo(const std::string& val) {
  this->buildInfo = val;
__isset.buildInfo = true;
}

void ServerProperties::__set_logo(const std::string& val) {
  this->logo = val;
__isset.logo = true;
}
std::ostream& operator<<(std::ostream& out, const ServerProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ServerProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_supportedTimeAggregationOperations = false;
  bool isset_timestampPrecision = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->supportedTimeAggregationOperations.clear();
            uint32_t _size596;
            ::apache::thrift::protocol::TType _etype599;
            xfer += iprot->readListBegin(_etype599, _size596);
            this->supportedTimeAggregationOperations.resize(_size596);
            uint32_t _i600;
            for (_i600 = 0; _i600 < _size596; ++_i600)
            {
              xfer += iprot->readString(this->supportedTimeAggregationOperations[_i600]);
            }
            xfer += iprot->readListEnd();
          }
          isset_supportedTimeAggregationOperations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestampPrecision);
          isset_timestampPrecision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxConcurrentClientNum);
          this->__isset.maxConcurrentClientNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->thriftMaxFrameSize);
          this->__isset.thriftMaxFrameSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReadOnly);
          this->__isset.isReadOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->buildInfo);
          this->__isset.buildInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->logo);
          this->__isset.logo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedTimeAggregationOperations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestampPrecision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServerProperties");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportedTimeAggregationOperations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->supportedTimeAggregationOperations.size()));
    std::vector<std::string> ::const_iterator _iter601;
    for (_iter601 = this->supportedTimeAggregationOperations.begin(); _iter601 != this->supportedTimeAggregationOperations.end(); ++_iter601)
    {
      xfer += oprot->writeString((*_iter601));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestampPrecision", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->timestampPrecision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxConcurrentClientNum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->maxConcurrentClientNum);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.thriftMaxFrameSize) {
    xfer += oprot->writeFieldBegin("thriftMaxFrameSize", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->thriftMaxFrameSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isReadOnly) {
    xfer += oprot->writeFieldBegin("isReadOnly", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->isReadOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.buildInfo) {
    xfer += oprot->writeFieldBegin("buildInfo", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->buildInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logo) {
    xfer += oprot->writeFieldBegin("logo", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->logo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerProperties &a, ServerProperties &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.supportedTimeAggregationOperations, b.supportedTimeAggregationOperations);
  swap(a.timestampPrecision, b.timestampPrecision);
  swap(a.maxConcurrentClientNum, b.maxConcurrentClientNum);
  swap(a.thriftMaxFrameSize, b.thriftMaxFrameSize);
  swap(a.isReadOnly, b.isReadOnly);
  swap(a.buildInfo, b.buildInfo);
  swap(a.logo, b.logo);
  swap(a.__isset, b.__isset);
}

ServerProperties::ServerProperties(const ServerProperties& other602) {
  version = other602.version;
  supportedTimeAggregationOperations = other602.supportedTimeAggregationOperations;
  timestampPrecision = other602.timestampPrecision;
  maxConcurrentClientNum = other602.maxConcurrentClientNum;
  thriftMaxFrameSize = other602.thriftMaxFrameSize;
  isReadOnly = other602.isReadOnly;
  buildInfo = other602.buildInfo;
  logo = other602.logo;
  __isset = other602.__isset;
}
ServerProperties& ServerProperties::operator=(const ServerProperties& other603) {
  version = other603.version;
  supportedTimeAggregationOperations = other603.supportedTimeAggregationOperations;
  timestampPrecision = other603.timestampPrecision;
  maxConcurrentClientNum = other603.maxConcurrentClientNum;
  thriftMaxFrameSize = other603.thriftMaxFrameSize;
  isReadOnly = other603.isReadOnly;
  buildInfo = other603.buildInfo;
  logo = other603.logo;
  __isset = other603.__isset;
  return *this;
}
void ServerProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServerProperties(";
  out << "version=" << to_string(version);
  out << ", " << "supportedTimeAggregationOperations=" << to_string(supportedTimeAggregationOperations);
  out << ", " << "timestampPrecision=" << to_string(timestampPrecision);
  out << ", " << "maxConcurrentClientNum=" << to_string(maxConcurrentClientNum);
  out << ", " << "thriftMaxFrameSize="; (__isset.thriftMaxFrameSize ? (out << to_string(thriftMaxFrameSize)) : (out << "<null>"));
  out << ", " << "isReadOnly="; (__isset.isReadOnly ? (out << to_string(isReadOnly)) : (out << "<null>"));
  out << ", " << "buildInfo="; (__isset.buildInfo ? (out << to_string(buildInfo)) : (out << "<null>"));
  out << ", " << "logo="; (__isset.logo ? (out << to_string(logo)) : (out << "<null>"));
  out << ")";
}


TSSetSchemaTemplateReq::~TSSetSchemaTemplateReq() noexcept {
}


void TSSetSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSSetSchemaTemplateReq::__set_templateName(const std::string& val) {
  this->templateName = val;
}

void TSSetSchemaTemplateReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}
std::ostream& operator<<(std::ostream& out, const TSSetSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSSetSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_templateName = false;
  bool isset_prefixPath = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->templateName);
          isset_templateName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_templateName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSSetSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSSetSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("templateName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->templateName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSSetSchemaTemplateReq &a, TSSetSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.templateName, b.templateName);
  swap(a.prefixPath, b.prefixPath);
}

TSSetSchemaTemplateReq::TSSetSchemaTemplateReq(const TSSetSchemaTemplateReq& other604) {
  sessionId = other604.sessionId;
  templateName = other604.templateName;
  prefixPath = other604.prefixPath;
}
TSSetSchemaTemplateReq& TSSetSchemaTemplateReq::operator=(const TSSetSchemaTemplateReq& other605) {
  sessionId = other605.sessionId;
  templateName = other605.templateName;
  prefixPath = other605.prefixPath;
  return *this;
}
void TSSetSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSSetSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "templateName=" << to_string(templateName);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ")";
}


TSCreateSchemaTemplateReq::~TSCreateSchemaTemplateReq() noexcept {
}


void TSCreateSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateSchemaTemplateReq::__set_name(const std::string& val) {
  this->name = val;
}

void TSCreateSchemaTemplateReq::__set_serializedTemplate(const std::string& val) {
  this->serializedTemplate = val;
}
std::ostream& operator<<(std::ostream& out, const TSCreateSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_name = false;
  bool isset_serializedTemplate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->serializedTemplate);
          isset_serializedTemplate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serializedTemplate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serializedTemplate", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->serializedTemplate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateSchemaTemplateReq &a, TSCreateSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.name, b.name);
  swap(a.serializedTemplate, b.serializedTemplate);
}

TSCreateSchemaTemplateReq::TSCreateSchemaTemplateReq(const TSCreateSchemaTemplateReq& other606) {
  sessionId = other606.sessionId;
  name = other606.name;
  serializedTemplate = other606.serializedTemplate;
}
TSCreateSchemaTemplateReq& TSCreateSchemaTemplateReq::operator=(const TSCreateSchemaTemplateReq& other607) {
  sessionId = other607.sessionId;
  name = other607.name;
  serializedTemplate = other607.serializedTemplate;
  return *this;
}
void TSCreateSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "serializedTemplate=" << to_string(serializedTemplate);
  out << ")";
}


TSAppendSchemaTemplateReq::~TSAppendSchemaTemplateReq() noexcept {
}


void TSAppendSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSAppendSchemaTemplateReq::__set_name(const std::string& val) {
  this->name = val;
}

void TSAppendSchemaTemplateReq::__set_isAligned(const bool val) {
  this->isAligned = val;
}

void TSAppendSchemaTemplateReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSAppendSchemaTemplateReq::__set_dataTypes(const std::vector<int32_t> & val) {
  this->dataTypes = val;
}

void TSAppendSchemaTemplateReq::__set_encodings(const std::vector<int32_t> & val) {
  this->encodings = val;
}

void TSAppendSchemaTemplateReq::__set_compressors(const std::vector<int32_t> & val) {
  this->compressors = val;
}
std::ostream& operator<<(std::ostream& out, const TSAppendSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSAppendSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_name = false;
  bool isset_isAligned = false;
  bool isset_measurements = false;
  bool isset_dataTypes = false;
  bool isset_encodings = false;
  bool isset_compressors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAligned);
          isset_isAligned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size608;
            ::apache::thrift::protocol::TType _etype611;
            xfer += iprot->readListBegin(_etype611, _size608);
            this->measurements.resize(_size608);
            uint32_t _i612;
            for (_i612 = 0; _i612 < _size608; ++_i612)
            {
              xfer += iprot->readString(this->measurements[_i612]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypes.clear();
            uint32_t _size613;
            ::apache::thrift::protocol::TType _etype616;
            xfer += iprot->readListBegin(_etype616, _size613);
            this->dataTypes.resize(_size613);
            uint32_t _i617;
            for (_i617 = 0; _i617 < _size613; ++_i617)
            {
              xfer += iprot->readI32(this->dataTypes[_i617]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encodings.clear();
            uint32_t _size618;
            ::apache::thrift::protocol::TType _etype621;
            xfer += iprot->readListBegin(_etype621, _size618);
            this->encodings.resize(_size618);
            uint32_t _i622;
            for (_i622 = 0; _i622 < _size618; ++_i622)
            {
              xfer += iprot->readI32(this->encodings[_i622]);
            }
            xfer += iprot->readListEnd();
          }
          isset_encodings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compressors.clear();
            uint32_t _size623;
            ::apache::thrift::protocol::TType _etype626;
            xfer += iprot->readListBegin(_etype626, _size623);
            this->compressors.resize(_size623);
            uint32_t _i627;
            for (_i627 = 0; _i627 < _size623; ++_i627)
            {
              xfer += iprot->readI32(this->compressors[_i627]);
            }
            xfer += iprot->readListEnd();
          }
          isset_compressors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAligned)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataTypes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encodings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSAppendSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSAppendSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAligned", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isAligned);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter628;
    for (_iter628 = this->measurements.begin(); _iter628 != this->measurements.end(); ++_iter628)
    {
      xfer += oprot->writeString((*_iter628));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataTypes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dataTypes.size()));
    std::vector<int32_t> ::const_iterator _iter629;
    for (_iter629 = this->dataTypes.begin(); _iter629 != this->dataTypes.end(); ++_iter629)
    {
      xfer += oprot->writeI32((*_iter629));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encodings", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->encodings.size()));
    std::vector<int32_t> ::const_iterator _iter630;
    for (_iter630 = this->encodings.begin(); _iter630 != this->encodings.end(); ++_iter630)
    {
      xfer += oprot->writeI32((*_iter630));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressors", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->compressors.size()));
    std::vector<int32_t> ::const_iterator _iter631;
    for (_iter631 = this->compressors.begin(); _iter631 != this->compressors.end(); ++_iter631)
    {
      xfer += oprot->writeI32((*_iter631));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSAppendSchemaTemplateReq &a, TSAppendSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.name, b.name);
  swap(a.isAligned, b.isAligned);
  swap(a.measurements, b.measurements);
  swap(a.dataTypes, b.dataTypes);
  swap(a.encodings, b.encodings);
  swap(a.compressors, b.compressors);
}

TSAppendSchemaTemplateReq::TSAppendSchemaTemplateReq(const TSAppendSchemaTemplateReq& other632) {
  sessionId = other632.sessionId;
  name = other632.name;
  isAligned = other632.isAligned;
  measurements = other632.measurements;
  dataTypes = other632.dataTypes;
  encodings = other632.encodings;
  compressors = other632.compressors;
}
TSAppendSchemaTemplateReq& TSAppendSchemaTemplateReq::operator=(const TSAppendSchemaTemplateReq& other633) {
  sessionId = other633.sessionId;
  name = other633.name;
  isAligned = other633.isAligned;
  measurements = other633.measurements;
  dataTypes = other633.dataTypes;
  encodings = other633.encodings;
  compressors = other633.compressors;
  return *this;
}
void TSAppendSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSAppendSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "isAligned=" << to_string(isAligned);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "dataTypes=" << to_string(dataTypes);
  out << ", " << "encodings=" << to_string(encodings);
  out << ", " << "compressors=" << to_string(compressors);
  out << ")";
}


TSPruneSchemaTemplateReq::~TSPruneSchemaTemplateReq() noexcept {
}


void TSPruneSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSPruneSchemaTemplateReq::__set_name(const std::string& val) {
  this->name = val;
}

void TSPruneSchemaTemplateReq::__set_path(const std::string& val) {
  this->path = val;
}
std::ostream& operator<<(std::ostream& out, const TSPruneSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSPruneSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_name = false;
  bool isset_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSPruneSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSPruneSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSPruneSchemaTemplateReq &a, TSPruneSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.name, b.name);
  swap(a.path, b.path);
}

TSPruneSchemaTemplateReq::TSPruneSchemaTemplateReq(const TSPruneSchemaTemplateReq& other634) {
  sessionId = other634.sessionId;
  name = other634.name;
  path = other634.path;
}
TSPruneSchemaTemplateReq& TSPruneSchemaTemplateReq::operator=(const TSPruneSchemaTemplateReq& other635) {
  sessionId = other635.sessionId;
  name = other635.name;
  path = other635.path;
  return *this;
}
void TSPruneSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSPruneSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


TSQueryTemplateReq::~TSQueryTemplateReq() noexcept {
}


void TSQueryTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSQueryTemplateReq::__set_name(const std::string& val) {
  this->name = val;
}

void TSQueryTemplateReq::__set_queryType(const int32_t val) {
  this->queryType = val;
}

void TSQueryTemplateReq::__set_measurement(const std::string& val) {
  this->measurement = val;
__isset.measurement = true;
}
std::ostream& operator<<(std::ostream& out, const TSQueryTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_name = false;
  bool isset_queryType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryType);
          isset_queryType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measurement);
          this->__isset.measurement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->queryType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.measurement) {
    xfer += oprot->writeFieldBegin("measurement", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->measurement);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryTemplateReq &a, TSQueryTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.name, b.name);
  swap(a.queryType, b.queryType);
  swap(a.measurement, b.measurement);
  swap(a.__isset, b.__isset);
}

TSQueryTemplateReq::TSQueryTemplateReq(const TSQueryTemplateReq& other636) {
  sessionId = other636.sessionId;
  name = other636.name;
  queryType = other636.queryType;
  measurement = other636.measurement;
  __isset = other636.__isset;
}
TSQueryTemplateReq& TSQueryTemplateReq::operator=(const TSQueryTemplateReq& other637) {
  sessionId = other637.sessionId;
  name = other637.name;
  queryType = other637.queryType;
  measurement = other637.measurement;
  __isset = other637.__isset;
  return *this;
}
void TSQueryTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "queryType=" << to_string(queryType);
  out << ", " << "measurement="; (__isset.measurement ? (out << to_string(measurement)) : (out << "<null>"));
  out << ")";
}


TSQueryTemplateResp::~TSQueryTemplateResp() noexcept {
}


void TSQueryTemplateResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSQueryTemplateResp::__set_queryType(const int32_t val) {
  this->queryType = val;
}

void TSQueryTemplateResp::__set_result(const bool val) {
  this->result = val;
__isset.result = true;
}

void TSQueryTemplateResp::__set_count(const int32_t val) {
  this->count = val;
__isset.count = true;
}

void TSQueryTemplateResp::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
__isset.measurements = true;
}
std::ostream& operator<<(std::ostream& out, const TSQueryTemplateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryTemplateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_queryType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryType);
          isset_queryType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size638;
            ::apache::thrift::protocol::TType _etype641;
            xfer += iprot->readListBegin(_etype641, _size638);
            this->measurements.resize(_size638);
            uint32_t _i642;
            for (_i642 = 0; _i642 < _size638; ++_i642)
            {
              xfer += iprot->readString(this->measurements[_i642]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryTemplateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryTemplateResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->queryType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->result);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.count) {
    xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurements) {
    xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
      std::vector<std::string> ::const_iterator _iter643;
      for (_iter643 = this->measurements.begin(); _iter643 != this->measurements.end(); ++_iter643)
      {
        xfer += oprot->writeString((*_iter643));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryTemplateResp &a, TSQueryTemplateResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.queryType, b.queryType);
  swap(a.result, b.result);
  swap(a.count, b.count);
  swap(a.measurements, b.measurements);
  swap(a.__isset, b.__isset);
}

TSQueryTemplateResp::TSQueryTemplateResp(const TSQueryTemplateResp& other644) {
  status = other644.status;
  queryType = other644.queryType;
  result = other644.result;
  count = other644.count;
  measurements = other644.measurements;
  __isset = other644.__isset;
}
TSQueryTemplateResp& TSQueryTemplateResp::operator=(const TSQueryTemplateResp& other645) {
  status = other645.status;
  queryType = other645.queryType;
  result = other645.result;
  count = other645.count;
  measurements = other645.measurements;
  __isset = other645.__isset;
  return *this;
}
void TSQueryTemplateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryTemplateResp(";
  out << "status=" << to_string(status);
  out << ", " << "queryType=" << to_string(queryType);
  out << ", " << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ", " << "count="; (__isset.count ? (out << to_string(count)) : (out << "<null>"));
  out << ", " << "measurements="; (__isset.measurements ? (out << to_string(measurements)) : (out << "<null>"));
  out << ")";
}


TSUnsetSchemaTemplateReq::~TSUnsetSchemaTemplateReq() noexcept {
}


void TSUnsetSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSUnsetSchemaTemplateReq::__set_prefixPath(const std::string& val) {
  this->prefixPath = val;
}

void TSUnsetSchemaTemplateReq::__set_templateName(const std::string& val) {
  this->templateName = val;
}
std::ostream& operator<<(std::ostream& out, const TSUnsetSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSUnsetSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_prefixPath = false;
  bool isset_templateName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefixPath);
          isset_prefixPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->templateName);
          isset_templateName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prefixPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_templateName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSUnsetSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSUnsetSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefixPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->prefixPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("templateName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->templateName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSUnsetSchemaTemplateReq &a, TSUnsetSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.prefixPath, b.prefixPath);
  swap(a.templateName, b.templateName);
}

TSUnsetSchemaTemplateReq::TSUnsetSchemaTemplateReq(const TSUnsetSchemaTemplateReq& other646) {
  sessionId = other646.sessionId;
  prefixPath = other646.prefixPath;
  templateName = other646.templateName;
}
TSUnsetSchemaTemplateReq& TSUnsetSchemaTemplateReq::operator=(const TSUnsetSchemaTemplateReq& other647) {
  sessionId = other647.sessionId;
  prefixPath = other647.prefixPath;
  templateName = other647.templateName;
  return *this;
}
void TSUnsetSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSUnsetSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "prefixPath=" << to_string(prefixPath);
  out << ", " << "templateName=" << to_string(templateName);
  out << ")";
}


TSDropSchemaTemplateReq::~TSDropSchemaTemplateReq() noexcept {
}


void TSDropSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSDropSchemaTemplateReq::__set_templateName(const std::string& val) {
  this->templateName = val;
}
std::ostream& operator<<(std::ostream& out, const TSDropSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSDropSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_templateName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->templateName);
          isset_templateName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_templateName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSDropSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSDropSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("templateName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->templateName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSDropSchemaTemplateReq &a, TSDropSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.templateName, b.templateName);
}

TSDropSchemaTemplateReq::TSDropSchemaTemplateReq(const TSDropSchemaTemplateReq& other648) {
  sessionId = other648.sessionId;
  templateName = other648.templateName;
}
TSDropSchemaTemplateReq& TSDropSchemaTemplateReq::operator=(const TSDropSchemaTemplateReq& other649) {
  sessionId = other649.sessionId;
  templateName = other649.templateName;
  return *this;
}
void TSDropSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSDropSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "templateName=" << to_string(templateName);
  out << ")";
}


TCreateTimeseriesUsingSchemaTemplateReq::~TCreateTimeseriesUsingSchemaTemplateReq() noexcept {
}


void TCreateTimeseriesUsingSchemaTemplateReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TCreateTimeseriesUsingSchemaTemplateReq::__set_devicePathList(const std::vector<std::string> & val) {
  this->devicePathList = val;
}
std::ostream& operator<<(std::ostream& out, const TCreateTimeseriesUsingSchemaTemplateReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCreateTimeseriesUsingSchemaTemplateReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_devicePathList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->devicePathList.clear();
            uint32_t _size650;
            ::apache::thrift::protocol::TType _etype653;
            xfer += iprot->readListBegin(_etype653, _size650);
            this->devicePathList.resize(_size650);
            uint32_t _i654;
            for (_i654 = 0; _i654 < _size650; ++_i654)
            {
              xfer += iprot->readString(this->devicePathList[_i654]);
            }
            xfer += iprot->readListEnd();
          }
          isset_devicePathList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_devicePathList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TCreateTimeseriesUsingSchemaTemplateReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateTimeseriesUsingSchemaTemplateReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devicePathList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->devicePathList.size()));
    std::vector<std::string> ::const_iterator _iter655;
    for (_iter655 = this->devicePathList.begin(); _iter655 != this->devicePathList.end(); ++_iter655)
    {
      xfer += oprot->writeString((*_iter655));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateTimeseriesUsingSchemaTemplateReq &a, TCreateTimeseriesUsingSchemaTemplateReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.devicePathList, b.devicePathList);
}

TCreateTimeseriesUsingSchemaTemplateReq::TCreateTimeseriesUsingSchemaTemplateReq(const TCreateTimeseriesUsingSchemaTemplateReq& other656) {
  sessionId = other656.sessionId;
  devicePathList = other656.devicePathList;
}
TCreateTimeseriesUsingSchemaTemplateReq& TCreateTimeseriesUsingSchemaTemplateReq::operator=(const TCreateTimeseriesUsingSchemaTemplateReq& other657) {
  sessionId = other657.sessionId;
  devicePathList = other657.devicePathList;
  return *this;
}
void TCreateTimeseriesUsingSchemaTemplateReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateTimeseriesUsingSchemaTemplateReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "devicePathList=" << to_string(devicePathList);
  out << ")";
}


TSyncIdentityInfo::~TSyncIdentityInfo() noexcept {
}


void TSyncIdentityInfo::__set_pipeName(const std::string& val) {
  this->pipeName = val;
}

void TSyncIdentityInfo::__set_createTime(const int64_t val) {
  this->createTime = val;
}

void TSyncIdentityInfo::__set_version(const std::string& val) {
  this->version = val;
}

void TSyncIdentityInfo::__set_database(const std::string& val) {
  this->database = val;
}
std::ostream& operator<<(std::ostream& out, const TSyncIdentityInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSyncIdentityInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pipeName = false;
  bool isset_createTime = false;
  bool isset_version = false;
  bool isset_database = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pipeName);
          isset_pipeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          isset_createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pipeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_createTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSyncIdentityInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSyncIdentityInfo");

  xfer += oprot->writeFieldBegin("pipeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pipeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSyncIdentityInfo &a, TSyncIdentityInfo &b) {
  using ::std::swap;
  swap(a.pipeName, b.pipeName);
  swap(a.createTime, b.createTime);
  swap(a.version, b.version);
  swap(a.database, b.database);
}

TSyncIdentityInfo::TSyncIdentityInfo(const TSyncIdentityInfo& other658) {
  pipeName = other658.pipeName;
  createTime = other658.createTime;
  version = other658.version;
  database = other658.database;
}
TSyncIdentityInfo& TSyncIdentityInfo::operator=(const TSyncIdentityInfo& other659) {
  pipeName = other659.pipeName;
  createTime = other659.createTime;
  version = other659.version;
  database = other659.database;
  return *this;
}
void TSyncIdentityInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSyncIdentityInfo(";
  out << "pipeName=" << to_string(pipeName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "version=" << to_string(version);
  out << ", " << "database=" << to_string(database);
  out << ")";
}


TSyncTransportMetaInfo::~TSyncTransportMetaInfo() noexcept {
}


void TSyncTransportMetaInfo::__set_fileName(const std::string& val) {
  this->fileName = val;
}

void TSyncTransportMetaInfo::__set_startIndex(const int64_t val) {
  this->startIndex = val;
}
std::ostream& operator<<(std::ostream& out, const TSyncTransportMetaInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSyncTransportMetaInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileName = false;
  bool isset_startIndex = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fileName);
          isset_fileName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startIndex);
          isset_startIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSyncTransportMetaInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSyncTransportMetaInfo");

  xfer += oprot->writeFieldBegin("fileName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fileName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startIndex", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->startIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSyncTransportMetaInfo &a, TSyncTransportMetaInfo &b) {
  using ::std::swap;
  swap(a.fileName, b.fileName);
  swap(a.startIndex, b.startIndex);
}

TSyncTransportMetaInfo::TSyncTransportMetaInfo(const TSyncTransportMetaInfo& other660) {
  fileName = other660.fileName;
  startIndex = other660.startIndex;
}
TSyncTransportMetaInfo& TSyncTransportMetaInfo::operator=(const TSyncTransportMetaInfo& other661) {
  fileName = other661.fileName;
  startIndex = other661.startIndex;
  return *this;
}
void TSyncTransportMetaInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSyncTransportMetaInfo(";
  out << "fileName=" << to_string(fileName);
  out << ", " << "startIndex=" << to_string(startIndex);
  out << ")";
}


TPipeTransferReq::~TPipeTransferReq() noexcept {
}


void TPipeTransferReq::__set_version(const int8_t val) {
  this->version = val;
}

void TPipeTransferReq::__set_type(const int16_t val) {
  this->type = val;
}

void TPipeTransferReq::__set_body(const std::string& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const TPipeTransferReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPipeTransferReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_type = false;
  bool isset_body = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          isset_body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_body)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPipeTransferReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPipeTransferReq");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPipeTransferReq &a, TPipeTransferReq &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.type, b.type);
  swap(a.body, b.body);
}

TPipeTransferReq::TPipeTransferReq(const TPipeTransferReq& other662) {
  version = other662.version;
  type = other662.type;
  body = other662.body;
}
TPipeTransferReq& TPipeTransferReq::operator=(const TPipeTransferReq& other663) {
  version = other663.version;
  type = other663.type;
  body = other663.body;
  return *this;
}
void TPipeTransferReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPipeTransferReq(";
  out << "version=" << to_string(version);
  out << ", " << "type=" << to_string(type);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


TPipeTransferResp::~TPipeTransferResp() noexcept {
}


void TPipeTransferResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TPipeTransferResp::__set_body(const std::string& val) {
  this->body = val;
__isset.body = true;
}
std::ostream& operator<<(std::ostream& out, const TPipeTransferResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPipeTransferResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPipeTransferResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPipeTransferResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->body);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPipeTransferResp &a, TPipeTransferResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

TPipeTransferResp::TPipeTransferResp(const TPipeTransferResp& other664) {
  status = other664.status;
  body = other664.body;
  __isset = other664.__isset;
}
TPipeTransferResp& TPipeTransferResp::operator=(const TPipeTransferResp& other665) {
  status = other665.status;
  body = other665.body;
  __isset = other665.__isset;
  return *this;
}
void TPipeTransferResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPipeTransferResp(";
  out << "status=" << to_string(status);
  out << ", " << "body="; (__isset.body ? (out << to_string(body)) : (out << "<null>"));
  out << ")";
}


TPipeSubscribeReq::~TPipeSubscribeReq() noexcept {
}


void TPipeSubscribeReq::__set_version(const int8_t val) {
  this->version = val;
}

void TPipeSubscribeReq::__set_type(const int16_t val) {
  this->type = val;
}

void TPipeSubscribeReq::__set_body(const std::string& val) {
  this->body = val;
__isset.body = true;
}
std::ostream& operator<<(std::ostream& out, const TPipeSubscribeReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPipeSubscribeReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPipeSubscribeReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPipeSubscribeReq");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->body);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPipeSubscribeReq &a, TPipeSubscribeReq &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.type, b.type);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

TPipeSubscribeReq::TPipeSubscribeReq(const TPipeSubscribeReq& other666) {
  version = other666.version;
  type = other666.type;
  body = other666.body;
  __isset = other666.__isset;
}
TPipeSubscribeReq& TPipeSubscribeReq::operator=(const TPipeSubscribeReq& other667) {
  version = other667.version;
  type = other667.type;
  body = other667.body;
  __isset = other667.__isset;
  return *this;
}
void TPipeSubscribeReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPipeSubscribeReq(";
  out << "version=" << to_string(version);
  out << ", " << "type=" << to_string(type);
  out << ", " << "body="; (__isset.body ? (out << to_string(body)) : (out << "<null>"));
  out << ")";
}


TPipeSubscribeResp::~TPipeSubscribeResp() noexcept {
}


void TPipeSubscribeResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TPipeSubscribeResp::__set_version(const int8_t val) {
  this->version = val;
}

void TPipeSubscribeResp::__set_type(const int16_t val) {
  this->type = val;
}

void TPipeSubscribeResp::__set_body(const std::vector<std::string> & val) {
  this->body = val;
__isset.body = true;
}
std::ostream& operator<<(std::ostream& out, const TPipeSubscribeResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPipeSubscribeResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_version = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->body.clear();
            uint32_t _size668;
            ::apache::thrift::protocol::TType _etype671;
            xfer += iprot->readListBegin(_etype671, _size668);
            this->body.resize(_size668);
            uint32_t _i672;
            for (_i672 = 0; _i672 < _size668; ++_i672)
            {
              xfer += iprot->readBinary(this->body[_i672]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPipeSubscribeResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPipeSubscribeResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->body.size()));
      std::vector<std::string> ::const_iterator _iter673;
      for (_iter673 = this->body.begin(); _iter673 != this->body.end(); ++_iter673)
      {
        xfer += oprot->writeBinary((*_iter673));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPipeSubscribeResp &a, TPipeSubscribeResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.version, b.version);
  swap(a.type, b.type);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

TPipeSubscribeResp::TPipeSubscribeResp(const TPipeSubscribeResp& other674) {
  status = other674.status;
  version = other674.version;
  type = other674.type;
  body = other674.body;
  __isset = other674.__isset;
}
TPipeSubscribeResp& TPipeSubscribeResp::operator=(const TPipeSubscribeResp& other675) {
  status = other675.status;
  version = other675.version;
  type = other675.type;
  body = other675.body;
  __isset = other675.__isset;
  return *this;
}
void TPipeSubscribeResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPipeSubscribeResp(";
  out << "status=" << to_string(status);
  out << ", " << "version=" << to_string(version);
  out << ", " << "type=" << to_string(type);
  out << ", " << "body="; (__isset.body ? (out << to_string(body)) : (out << "<null>"));
  out << ")";
}


TSBackupConfigurationResp::~TSBackupConfigurationResp() noexcept {
}


void TSBackupConfigurationResp::__set_status(const  ::TSStatus& val) {
  this->status = val;
}

void TSBackupConfigurationResp::__set_enableOperationSync(const bool val) {
  this->enableOperationSync = val;
__isset.enableOperationSync = true;
}

void TSBackupConfigurationResp::__set_secondaryAddress(const std::string& val) {
  this->secondaryAddress = val;
__isset.secondaryAddress = true;
}

void TSBackupConfigurationResp::__set_secondaryPort(const int32_t val) {
  this->secondaryPort = val;
__isset.secondaryPort = true;
}
std::ostream& operator<<(std::ostream& out, const TSBackupConfigurationResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSBackupConfigurationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enableOperationSync);
          this->__isset.enableOperationSync = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secondaryAddress);
          this->__isset.secondaryAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secondaryPort);
          this->__isset.secondaryPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSBackupConfigurationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSBackupConfigurationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.enableOperationSync) {
    xfer += oprot->writeFieldBegin("enableOperationSync", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->enableOperationSync);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secondaryAddress) {
    xfer += oprot->writeFieldBegin("secondaryAddress", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->secondaryAddress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secondaryPort) {
    xfer += oprot->writeFieldBegin("secondaryPort", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->secondaryPort);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSBackupConfigurationResp &a, TSBackupConfigurationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.enableOperationSync, b.enableOperationSync);
  swap(a.secondaryAddress, b.secondaryAddress);
  swap(a.secondaryPort, b.secondaryPort);
  swap(a.__isset, b.__isset);
}

TSBackupConfigurationResp::TSBackupConfigurationResp(const TSBackupConfigurationResp& other676) {
  status = other676.status;
  enableOperationSync = other676.enableOperationSync;
  secondaryAddress = other676.secondaryAddress;
  secondaryPort = other676.secondaryPort;
  __isset = other676.__isset;
}
TSBackupConfigurationResp& TSBackupConfigurationResp::operator=(const TSBackupConfigurationResp& other677) {
  status = other677.status;
  enableOperationSync = other677.enableOperationSync;
  secondaryAddress = other677.secondaryAddress;
  secondaryPort = other677.secondaryPort;
  __isset = other677.__isset;
  return *this;
}
void TSBackupConfigurationResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSBackupConfigurationResp(";
  out << "status=" << to_string(status);
  out << ", " << "enableOperationSync="; (__isset.enableOperationSync ? (out << to_string(enableOperationSync)) : (out << "<null>"));
  out << ", " << "secondaryAddress="; (__isset.secondaryAddress ? (out << to_string(secondaryAddress)) : (out << "<null>"));
  out << ", " << "secondaryPort="; (__isset.secondaryPort ? (out << to_string(secondaryPort)) : (out << "<null>"));
  out << ")";
}


TSConnectionInfo::~TSConnectionInfo() noexcept {
}


void TSConnectionInfo::__set_userName(const std::string& val) {
  this->userName = val;
}

void TSConnectionInfo::__set_logInTime(const int64_t val) {
  this->logInTime = val;
}

void TSConnectionInfo::__set_connectionId(const std::string& val) {
  this->connectionId = val;
}

void TSConnectionInfo::__set_type(const TSConnectionType::type val) {
  this->type = val;
}
std::ostream& operator<<(std::ostream& out, const TSConnectionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSConnectionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_userName = false;
  bool isset_logInTime = false;
  bool isset_connectionId = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          isset_userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->logInTime);
          isset_logInTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connectionId);
          isset_connectionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast678;
          xfer += iprot->readI32(ecast678);
          this->type = (TSConnectionType::type)ecast678;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_userName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_logInTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_connectionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSConnectionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSConnectionInfo");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("logInTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->logInTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connectionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->connectionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSConnectionInfo &a, TSConnectionInfo &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.logInTime, b.logInTime);
  swap(a.connectionId, b.connectionId);
  swap(a.type, b.type);
}

TSConnectionInfo::TSConnectionInfo(const TSConnectionInfo& other679) {
  userName = other679.userName;
  logInTime = other679.logInTime;
  connectionId = other679.connectionId;
  type = other679.type;
}
TSConnectionInfo& TSConnectionInfo::operator=(const TSConnectionInfo& other680) {
  userName = other680.userName;
  logInTime = other680.logInTime;
  connectionId = other680.connectionId;
  type = other680.type;
  return *this;
}
void TSConnectionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSConnectionInfo(";
  out << "userName=" << to_string(userName);
  out << ", " << "logInTime=" << to_string(logInTime);
  out << ", " << "connectionId=" << to_string(connectionId);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


TSConnectionInfoResp::~TSConnectionInfoResp() noexcept {
}


void TSConnectionInfoResp::__set_connectionInfoList(const std::vector<TSConnectionInfo> & val) {
  this->connectionInfoList = val;
}
std::ostream& operator<<(std::ostream& out, const TSConnectionInfoResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSConnectionInfoResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_connectionInfoList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->connectionInfoList.clear();
            uint32_t _size681;
            ::apache::thrift::protocol::TType _etype684;
            xfer += iprot->readListBegin(_etype684, _size681);
            this->connectionInfoList.resize(_size681);
            uint32_t _i685;
            for (_i685 = 0; _i685 < _size681; ++_i685)
            {
              xfer += this->connectionInfoList[_i685].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_connectionInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_connectionInfoList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSConnectionInfoResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSConnectionInfoResp");

  xfer += oprot->writeFieldBegin("connectionInfoList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->connectionInfoList.size()));
    std::vector<TSConnectionInfo> ::const_iterator _iter686;
    for (_iter686 = this->connectionInfoList.begin(); _iter686 != this->connectionInfoList.end(); ++_iter686)
    {
      xfer += (*_iter686).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSConnectionInfoResp &a, TSConnectionInfoResp &b) {
  using ::std::swap;
  swap(a.connectionInfoList, b.connectionInfoList);
}

TSConnectionInfoResp::TSConnectionInfoResp(const TSConnectionInfoResp& other687) {
  connectionInfoList = other687.connectionInfoList;
}
TSConnectionInfoResp& TSConnectionInfoResp::operator=(const TSConnectionInfoResp& other688) {
  connectionInfoList = other688.connectionInfoList;
  return *this;
}
void TSConnectionInfoResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSConnectionInfoResp(";
  out << "connectionInfoList=" << to_string(connectionInfoList);
  out << ")";
}


