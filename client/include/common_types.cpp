/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "common_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTConsensusGroupTypeValues[] = {
  TConsensusGroupType::ConfigRegion,
  TConsensusGroupType::DataRegion,
  TConsensusGroupType::SchemaRegion
};
const char* _kTConsensusGroupTypeNames[] = {
  "ConfigRegion",
  "DataRegion",
  "SchemaRegion"
};
const std::map<int, const char*> _TConsensusGroupType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTConsensusGroupTypeValues, _kTConsensusGroupTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TConsensusGroupType::type& val) {
  std::map<int, const char*>::const_iterator it = _TConsensusGroupType_VALUES_TO_NAMES.find(val);
  if (it != _TConsensusGroupType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TConsensusGroupType::type& val) {
  std::map<int, const char*>::const_iterator it = _TConsensusGroupType_VALUES_TO_NAMES.find(val);
  if (it != _TConsensusGroupType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTRegionMigrateFailedTypeValues[] = {
  TRegionMigrateFailedType::AddPeerFailed,
  TRegionMigrateFailedType::RemovePeerFailed,
  TRegionMigrateFailedType::RemoveConsensusGroupFailed,
  TRegionMigrateFailedType::DeleteRegionFailed,
  TRegionMigrateFailedType::CreateRegionFailed,
  TRegionMigrateFailedType::Disconnect
};
const char* _kTRegionMigrateFailedTypeNames[] = {
  "AddPeerFailed",
  "RemovePeerFailed",
  "RemoveConsensusGroupFailed",
  "DeleteRegionFailed",
  "CreateRegionFailed",
  "Disconnect"
};
const std::map<int, const char*> _TRegionMigrateFailedType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTRegionMigrateFailedTypeValues, _kTRegionMigrateFailedTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TRegionMigrateFailedType::type& val) {
  std::map<int, const char*>::const_iterator it = _TRegionMigrateFailedType_VALUES_TO_NAMES.find(val);
  if (it != _TRegionMigrateFailedType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TRegionMigrateFailedType::type& val) {
  std::map<int, const char*>::const_iterator it = _TRegionMigrateFailedType_VALUES_TO_NAMES.find(val);
  if (it != _TRegionMigrateFailedType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTRegionMaintainTaskStatusValues[] = {
  TRegionMaintainTaskStatus::TASK_NOT_EXIST,
  TRegionMaintainTaskStatus::PROCESSING,
  TRegionMaintainTaskStatus::SUCCESS,
  TRegionMaintainTaskStatus::FAIL
};
const char* _kTRegionMaintainTaskStatusNames[] = {
  "TASK_NOT_EXIST",
  "PROCESSING",
  "SUCCESS",
  "FAIL"
};
const std::map<int, const char*> _TRegionMaintainTaskStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTRegionMaintainTaskStatusValues, _kTRegionMaintainTaskStatusNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TRegionMaintainTaskStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TRegionMaintainTaskStatus_VALUES_TO_NAMES.find(val);
  if (it != _TRegionMaintainTaskStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TRegionMaintainTaskStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _TRegionMaintainTaskStatus_VALUES_TO_NAMES.find(val);
  if (it != _TRegionMaintainTaskStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kThrottleTypeValues[] = {
  ThrottleType::REQUEST_NUMBER,
  ThrottleType::REQUEST_SIZE,
  ThrottleType::WRITE_NUMBER,
  ThrottleType::WRITE_SIZE,
  ThrottleType::READ_NUMBER,
  ThrottleType::READ_SIZE
};
const char* _kThrottleTypeNames[] = {
  "REQUEST_NUMBER",
  "REQUEST_SIZE",
  "WRITE_NUMBER",
  "WRITE_SIZE",
  "READ_NUMBER",
  "READ_SIZE"
};
const std::map<int, const char*> _ThrottleType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kThrottleTypeValues, _kThrottleTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ThrottleType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThrottleType_VALUES_TO_NAMES.find(val);
  if (it != _ThrottleType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ThrottleType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThrottleType_VALUES_TO_NAMES.find(val);
  if (it != _ThrottleType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTServiceTypeValues[] = {
  TServiceType::ConfigNodeInternalService,
  TServiceType::DataNodeInternalService,
  TServiceType::DataNodeMPPService,
  TServiceType::DataNodeExternalService
};
const char* _kTServiceTypeNames[] = {
  "ConfigNodeInternalService",
  "DataNodeInternalService",
  "DataNodeMPPService",
  "DataNodeExternalService"
};
const std::map<int, const char*> _TServiceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTServiceTypeValues, _kTServiceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TServiceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TServiceType_VALUES_TO_NAMES.find(val);
  if (it != _TServiceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TServiceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TServiceType_VALUES_TO_NAMES.find(val);
  if (it != _TServiceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTAggregationTypeValues[] = {
  TAggregationType::COUNT,
  TAggregationType::AVG,
  TAggregationType::SUM,
  TAggregationType::FIRST_VALUE,
  TAggregationType::LAST_VALUE,
  TAggregationType::MAX_TIME,
  TAggregationType::MIN_TIME,
  TAggregationType::MAX_VALUE,
  TAggregationType::MIN_VALUE,
  TAggregationType::EXTREME,
  TAggregationType::COUNT_IF,
  TAggregationType::TIME_DURATION,
  TAggregationType::MODE,
  TAggregationType::COUNT_TIME,
  TAggregationType::STDDEV,
  TAggregationType::STDDEV_POP,
  TAggregationType::STDDEV_SAMP,
  TAggregationType::VARIANCE,
  TAggregationType::VAR_POP,
  TAggregationType::VAR_SAMP,
  TAggregationType::MAX_BY,
  TAggregationType::MIN_BY,
  TAggregationType::UDAF,
  TAggregationType::FIRST,
  TAggregationType::LAST,
  TAggregationType::FIRST_BY,
  TAggregationType::LAST_BY,
  TAggregationType::MIN,
  TAggregationType::MAX,
  TAggregationType::COUNT_ALL,
  TAggregationType::APPROX_COUNT_DISTINCT,
  TAggregationType::APPROX_MOST_FREQUENT
};
const char* _kTAggregationTypeNames[] = {
  "COUNT",
  "AVG",
  "SUM",
  "FIRST_VALUE",
  "LAST_VALUE",
  "MAX_TIME",
  "MIN_TIME",
  "MAX_VALUE",
  "MIN_VALUE",
  "EXTREME",
  "COUNT_IF",
  "TIME_DURATION",
  "MODE",
  "COUNT_TIME",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  "MAX_BY",
  "MIN_BY",
  "UDAF",
  "FIRST",
  "LAST",
  "FIRST_BY",
  "LAST_BY",
  "MIN",
  "MAX",
  "COUNT_ALL",
  "APPROX_COUNT_DISTINCT",
  "APPROX_MOST_FREQUENT"
};
const std::map<int, const char*> _TAggregationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(32, _kTAggregationTypeValues, _kTAggregationTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TAggregationType::type& val) {
  std::map<int, const char*>::const_iterator it = _TAggregationType_VALUES_TO_NAMES.find(val);
  if (it != _TAggregationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TAggregationType::type& val) {
  std::map<int, const char*>::const_iterator it = _TAggregationType_VALUES_TO_NAMES.find(val);
  if (it != _TAggregationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTrainingStateValues[] = {
  TrainingState::PENDING,
  TrainingState::RUNNING,
  TrainingState::FINISHED,
  TrainingState::FAILED,
  TrainingState::DROPPING
};
const char* _kTrainingStateNames[] = {
  "PENDING",
  "RUNNING",
  "FINISHED",
  "FAILED",
  "DROPPING"
};
const std::map<int, const char*> _TrainingState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTrainingStateValues, _kTrainingStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TrainingState::type& val) {
  std::map<int, const char*>::const_iterator it = _TrainingState_VALUES_TO_NAMES.find(val);
  if (it != _TrainingState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TrainingState::type& val) {
  std::map<int, const char*>::const_iterator it = _TrainingState_VALUES_TO_NAMES.find(val);
  if (it != _TrainingState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kModelValues[] = {
  Model::TREE,
  Model::TABLE
};
const char* _kModelNames[] = {
  "TREE",
  "TABLE"
};
const std::map<int, const char*> _Model_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kModelValues, _kModelNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Model::type& val) {
  std::map<int, const char*>::const_iterator it = _Model_VALUES_TO_NAMES.find(val);
  if (it != _Model_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Model::type& val) {
  std::map<int, const char*>::const_iterator it = _Model_VALUES_TO_NAMES.find(val);
  if (it != _Model_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFunctionTypeValues[] = {
  FunctionType::NONE,
  FunctionType::SCALAR,
  FunctionType::AGGREGATE,
  FunctionType::TABLE
};
const char* _kFunctionTypeNames[] = {
  "NONE",
  "SCALAR",
  "AGGREGATE",
  "TABLE"
};
const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFunctionTypeValues, _kFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TEndPoint::~TEndPoint() noexcept {
}


void TEndPoint::__set_ip(const std::string& val) {
  this->ip = val;
}

void TEndPoint::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const TEndPoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TEndPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ip = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          isset_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ip)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TEndPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TEndPoint");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TEndPoint &a, TEndPoint &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
}

TEndPoint::TEndPoint(const TEndPoint& other0) {
  ip = other0.ip;
  port = other0.port;
}
TEndPoint& TEndPoint::operator=(const TEndPoint& other1) {
  ip = other1.ip;
  port = other1.port;
  return *this;
}
void TEndPoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TEndPoint(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


TSStatus::~TSStatus() noexcept {
}


void TSStatus::__set_code(const int32_t val) {
  this->code = val;
}

void TSStatus::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void TSStatus::__set_subStatus(const std::vector<TSStatus> & val) {
  this->subStatus = val;
__isset.subStatus = true;
}

void TSStatus::__set_redirectNode(const TEndPoint& val) {
  this->redirectNode = val;
__isset.redirectNode = true;
}

void TSStatus::__set_needRetry(const bool val) {
  this->needRetry = val;
__isset.needRetry = true;
}
std::ostream& operator<<(std::ostream& out, const TSStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subStatus.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->subStatus.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->subStatus[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->redirectNode.read(iprot);
          this->__isset.redirectNode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needRetry);
          this->__isset.needRetry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSStatus");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subStatus) {
    xfer += oprot->writeFieldBegin("subStatus", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->subStatus.size()));
      std::vector<TSStatus> ::const_iterator _iter7;
      for (_iter7 = this->subStatus.begin(); _iter7 != this->subStatus.end(); ++_iter7)
      {
        xfer += (*_iter7).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.redirectNode) {
    xfer += oprot->writeFieldBegin("redirectNode", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->redirectNode.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.needRetry) {
    xfer += oprot->writeFieldBegin("needRetry", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->needRetry);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSStatus &a, TSStatus &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.subStatus, b.subStatus);
  swap(a.redirectNode, b.redirectNode);
  swap(a.needRetry, b.needRetry);
  swap(a.__isset, b.__isset);
}

TSStatus::TSStatus(const TSStatus& other8) {
  code = other8.code;
  message = other8.message;
  subStatus = other8.subStatus;
  redirectNode = other8.redirectNode;
  needRetry = other8.needRetry;
  __isset = other8.__isset;
}
TSStatus& TSStatus::operator=(const TSStatus& other9) {
  code = other9.code;
  message = other9.message;
  subStatus = other9.subStatus;
  redirectNode = other9.redirectNode;
  needRetry = other9.needRetry;
  __isset = other9.__isset;
  return *this;
}
void TSStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSStatus(";
  out << "code=" << to_string(code);
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ", " << "subStatus="; (__isset.subStatus ? (out << to_string(subStatus)) : (out << "<null>"));
  out << ", " << "redirectNode="; (__isset.redirectNode ? (out << to_string(redirectNode)) : (out << "<null>"));
  out << ", " << "needRetry="; (__isset.needRetry ? (out << to_string(needRetry)) : (out << "<null>"));
  out << ")";
}


TConsensusGroupId::~TConsensusGroupId() noexcept {
}


void TConsensusGroupId::__set_type(const TConsensusGroupType::type val) {
  this->type = val;
}

void TConsensusGroupId::__set_id(const int32_t val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TConsensusGroupId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TConsensusGroupId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->type = (TConsensusGroupType::type)ecast10;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TConsensusGroupId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TConsensusGroupId");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TConsensusGroupId &a, TConsensusGroupId &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.id, b.id);
}

TConsensusGroupId::TConsensusGroupId(const TConsensusGroupId& other11) {
  type = other11.type;
  id = other11.id;
}
TConsensusGroupId& TConsensusGroupId::operator=(const TConsensusGroupId& other12) {
  type = other12.type;
  id = other12.id;
  return *this;
}
void TConsensusGroupId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TConsensusGroupId(";
  out << "type=" << to_string(type);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


TSeriesPartitionSlot::~TSeriesPartitionSlot() noexcept {
}


void TSeriesPartitionSlot::__set_slotId(const int32_t val) {
  this->slotId = val;
}
std::ostream& operator<<(std::ostream& out, const TSeriesPartitionSlot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSeriesPartitionSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_slotId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slotId);
          isset_slotId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_slotId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSeriesPartitionSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSeriesPartitionSlot");

  xfer += oprot->writeFieldBegin("slotId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->slotId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSeriesPartitionSlot &a, TSeriesPartitionSlot &b) {
  using ::std::swap;
  swap(a.slotId, b.slotId);
}

TSeriesPartitionSlot::TSeriesPartitionSlot(const TSeriesPartitionSlot& other13) {
  slotId = other13.slotId;
}
TSeriesPartitionSlot& TSeriesPartitionSlot::operator=(const TSeriesPartitionSlot& other14) {
  slotId = other14.slotId;
  return *this;
}
void TSeriesPartitionSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSeriesPartitionSlot(";
  out << "slotId=" << to_string(slotId);
  out << ")";
}


TTimePartitionSlot::~TTimePartitionSlot() noexcept {
}


void TTimePartitionSlot::__set_startTime(const int64_t val) {
  this->startTime = val;
}
std::ostream& operator<<(std::ostream& out, const TTimePartitionSlot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTimePartitionSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_startTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimePartitionSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTimePartitionSlot");

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTimePartitionSlot &a, TTimePartitionSlot &b) {
  using ::std::swap;
  swap(a.startTime, b.startTime);
}

TTimePartitionSlot::TTimePartitionSlot(const TTimePartitionSlot& other15) {
  startTime = other15.startTime;
}
TTimePartitionSlot& TTimePartitionSlot::operator=(const TTimePartitionSlot& other16) {
  startTime = other16.startTime;
  return *this;
}
void TTimePartitionSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTimePartitionSlot(";
  out << "startTime=" << to_string(startTime);
  out << ")";
}


TRegionReplicaSet::~TRegionReplicaSet() noexcept {
}


void TRegionReplicaSet::__set_regionId(const TConsensusGroupId& val) {
  this->regionId = val;
}

void TRegionReplicaSet::__set_dataNodeLocations(const std::vector<TDataNodeLocation> & val) {
  this->dataNodeLocations = val;
}
std::ostream& operator<<(std::ostream& out, const TRegionReplicaSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRegionReplicaSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_regionId = false;
  bool isset_dataNodeLocations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->regionId.read(iprot);
          isset_regionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataNodeLocations.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->dataNodeLocations.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->dataNodeLocations[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataNodeLocations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_regionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataNodeLocations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRegionReplicaSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRegionReplicaSet");

  xfer += oprot->writeFieldBegin("regionId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->regionId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataNodeLocations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataNodeLocations.size()));
    std::vector<TDataNodeLocation> ::const_iterator _iter22;
    for (_iter22 = this->dataNodeLocations.begin(); _iter22 != this->dataNodeLocations.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRegionReplicaSet &a, TRegionReplicaSet &b) {
  using ::std::swap;
  swap(a.regionId, b.regionId);
  swap(a.dataNodeLocations, b.dataNodeLocations);
}

TRegionReplicaSet::TRegionReplicaSet(const TRegionReplicaSet& other23) {
  regionId = other23.regionId;
  dataNodeLocations = other23.dataNodeLocations;
}
TRegionReplicaSet& TRegionReplicaSet::operator=(const TRegionReplicaSet& other24) {
  regionId = other24.regionId;
  dataNodeLocations = other24.dataNodeLocations;
  return *this;
}
void TRegionReplicaSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRegionReplicaSet(";
  out << "regionId=" << to_string(regionId);
  out << ", " << "dataNodeLocations=" << to_string(dataNodeLocations);
  out << ")";
}


TNodeResource::~TNodeResource() noexcept {
}


void TNodeResource::__set_cpuCoreNum(const int32_t val) {
  this->cpuCoreNum = val;
}

void TNodeResource::__set_maxMemory(const int64_t val) {
  this->maxMemory = val;
}
std::ostream& operator<<(std::ostream& out, const TNodeResource& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeResource::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cpuCoreNum = false;
  bool isset_maxMemory = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cpuCoreNum);
          isset_cpuCoreNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxMemory);
          isset_maxMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cpuCoreNum)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxMemory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNodeResource::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeResource");

  xfer += oprot->writeFieldBegin("cpuCoreNum", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cpuCoreNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxMemory", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->maxMemory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeResource &a, TNodeResource &b) {
  using ::std::swap;
  swap(a.cpuCoreNum, b.cpuCoreNum);
  swap(a.maxMemory, b.maxMemory);
}

TNodeResource::TNodeResource(const TNodeResource& other25) {
  cpuCoreNum = other25.cpuCoreNum;
  maxMemory = other25.maxMemory;
}
TNodeResource& TNodeResource::operator=(const TNodeResource& other26) {
  cpuCoreNum = other26.cpuCoreNum;
  maxMemory = other26.maxMemory;
  return *this;
}
void TNodeResource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeResource(";
  out << "cpuCoreNum=" << to_string(cpuCoreNum);
  out << ", " << "maxMemory=" << to_string(maxMemory);
  out << ")";
}


TConfigNodeLocation::~TConfigNodeLocation() noexcept {
}


void TConfigNodeLocation::__set_configNodeId(const int32_t val) {
  this->configNodeId = val;
}

void TConfigNodeLocation::__set_internalEndPoint(const TEndPoint& val) {
  this->internalEndPoint = val;
}

void TConfigNodeLocation::__set_consensusEndPoint(const TEndPoint& val) {
  this->consensusEndPoint = val;
}
std::ostream& operator<<(std::ostream& out, const TConfigNodeLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TConfigNodeLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_configNodeId = false;
  bool isset_internalEndPoint = false;
  bool isset_consensusEndPoint = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->configNodeId);
          isset_configNodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->internalEndPoint.read(iprot);
          isset_internalEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consensusEndPoint.read(iprot);
          isset_consensusEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_configNodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_internalEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_consensusEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TConfigNodeLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TConfigNodeLocation");

  xfer += oprot->writeFieldBegin("configNodeId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->configNodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("internalEndPoint", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->internalEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("consensusEndPoint", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->consensusEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TConfigNodeLocation &a, TConfigNodeLocation &b) {
  using ::std::swap;
  swap(a.configNodeId, b.configNodeId);
  swap(a.internalEndPoint, b.internalEndPoint);
  swap(a.consensusEndPoint, b.consensusEndPoint);
}

TConfigNodeLocation::TConfigNodeLocation(const TConfigNodeLocation& other27) {
  configNodeId = other27.configNodeId;
  internalEndPoint = other27.internalEndPoint;
  consensusEndPoint = other27.consensusEndPoint;
}
TConfigNodeLocation& TConfigNodeLocation::operator=(const TConfigNodeLocation& other28) {
  configNodeId = other28.configNodeId;
  internalEndPoint = other28.internalEndPoint;
  consensusEndPoint = other28.consensusEndPoint;
  return *this;
}
void TConfigNodeLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TConfigNodeLocation(";
  out << "configNodeId=" << to_string(configNodeId);
  out << ", " << "internalEndPoint=" << to_string(internalEndPoint);
  out << ", " << "consensusEndPoint=" << to_string(consensusEndPoint);
  out << ")";
}


TDataNodeLocation::~TDataNodeLocation() noexcept {
}


void TDataNodeLocation::__set_dataNodeId(const int32_t val) {
  this->dataNodeId = val;
}

void TDataNodeLocation::__set_clientRpcEndPoint(const TEndPoint& val) {
  this->clientRpcEndPoint = val;
}

void TDataNodeLocation::__set_internalEndPoint(const TEndPoint& val) {
  this->internalEndPoint = val;
}

void TDataNodeLocation::__set_mPPDataExchangeEndPoint(const TEndPoint& val) {
  this->mPPDataExchangeEndPoint = val;
}

void TDataNodeLocation::__set_dataRegionConsensusEndPoint(const TEndPoint& val) {
  this->dataRegionConsensusEndPoint = val;
}

void TDataNodeLocation::__set_schemaRegionConsensusEndPoint(const TEndPoint& val) {
  this->schemaRegionConsensusEndPoint = val;
}
std::ostream& operator<<(std::ostream& out, const TDataNodeLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataNodeLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataNodeId = false;
  bool isset_clientRpcEndPoint = false;
  bool isset_internalEndPoint = false;
  bool isset_mPPDataExchangeEndPoint = false;
  bool isset_dataRegionConsensusEndPoint = false;
  bool isset_schemaRegionConsensusEndPoint = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dataNodeId);
          isset_dataNodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientRpcEndPoint.read(iprot);
          isset_clientRpcEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->internalEndPoint.read(iprot);
          isset_internalEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mPPDataExchangeEndPoint.read(iprot);
          isset_mPPDataExchangeEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataRegionConsensusEndPoint.read(iprot);
          isset_dataRegionConsensusEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schemaRegionConsensusEndPoint.read(iprot);
          isset_schemaRegionConsensusEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataNodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_clientRpcEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_internalEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mPPDataExchangeEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataRegionConsensusEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schemaRegionConsensusEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataNodeLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataNodeLocation");

  xfer += oprot->writeFieldBegin("dataNodeId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dataNodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clientRpcEndPoint", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->clientRpcEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("internalEndPoint", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->internalEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mPPDataExchangeEndPoint", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->mPPDataExchangeEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataRegionConsensusEndPoint", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->dataRegionConsensusEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaRegionConsensusEndPoint", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->schemaRegionConsensusEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataNodeLocation &a, TDataNodeLocation &b) {
  using ::std::swap;
  swap(a.dataNodeId, b.dataNodeId);
  swap(a.clientRpcEndPoint, b.clientRpcEndPoint);
  swap(a.internalEndPoint, b.internalEndPoint);
  swap(a.mPPDataExchangeEndPoint, b.mPPDataExchangeEndPoint);
  swap(a.dataRegionConsensusEndPoint, b.dataRegionConsensusEndPoint);
  swap(a.schemaRegionConsensusEndPoint, b.schemaRegionConsensusEndPoint);
}

TDataNodeLocation::TDataNodeLocation(const TDataNodeLocation& other29) {
  dataNodeId = other29.dataNodeId;
  clientRpcEndPoint = other29.clientRpcEndPoint;
  internalEndPoint = other29.internalEndPoint;
  mPPDataExchangeEndPoint = other29.mPPDataExchangeEndPoint;
  dataRegionConsensusEndPoint = other29.dataRegionConsensusEndPoint;
  schemaRegionConsensusEndPoint = other29.schemaRegionConsensusEndPoint;
}
TDataNodeLocation& TDataNodeLocation::operator=(const TDataNodeLocation& other30) {
  dataNodeId = other30.dataNodeId;
  clientRpcEndPoint = other30.clientRpcEndPoint;
  internalEndPoint = other30.internalEndPoint;
  mPPDataExchangeEndPoint = other30.mPPDataExchangeEndPoint;
  dataRegionConsensusEndPoint = other30.dataRegionConsensusEndPoint;
  schemaRegionConsensusEndPoint = other30.schemaRegionConsensusEndPoint;
  return *this;
}
void TDataNodeLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataNodeLocation(";
  out << "dataNodeId=" << to_string(dataNodeId);
  out << ", " << "clientRpcEndPoint=" << to_string(clientRpcEndPoint);
  out << ", " << "internalEndPoint=" << to_string(internalEndPoint);
  out << ", " << "mPPDataExchangeEndPoint=" << to_string(mPPDataExchangeEndPoint);
  out << ", " << "dataRegionConsensusEndPoint=" << to_string(dataRegionConsensusEndPoint);
  out << ", " << "schemaRegionConsensusEndPoint=" << to_string(schemaRegionConsensusEndPoint);
  out << ")";
}


TAINodeLocation::~TAINodeLocation() noexcept {
}


void TAINodeLocation::__set_aiNodeId(const int32_t val) {
  this->aiNodeId = val;
}

void TAINodeLocation::__set_internalEndPoint(const TEndPoint& val) {
  this->internalEndPoint = val;
}
std::ostream& operator<<(std::ostream& out, const TAINodeLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAINodeLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aiNodeId = false;
  bool isset_internalEndPoint = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aiNodeId);
          isset_aiNodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->internalEndPoint.read(iprot);
          isset_internalEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aiNodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_internalEndPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAINodeLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAINodeLocation");

  xfer += oprot->writeFieldBegin("aiNodeId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->aiNodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("internalEndPoint", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->internalEndPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAINodeLocation &a, TAINodeLocation &b) {
  using ::std::swap;
  swap(a.aiNodeId, b.aiNodeId);
  swap(a.internalEndPoint, b.internalEndPoint);
}

TAINodeLocation::TAINodeLocation(const TAINodeLocation& other31) {
  aiNodeId = other31.aiNodeId;
  internalEndPoint = other31.internalEndPoint;
}
TAINodeLocation& TAINodeLocation::operator=(const TAINodeLocation& other32) {
  aiNodeId = other32.aiNodeId;
  internalEndPoint = other32.internalEndPoint;
  return *this;
}
void TAINodeLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAINodeLocation(";
  out << "aiNodeId=" << to_string(aiNodeId);
  out << ", " << "internalEndPoint=" << to_string(internalEndPoint);
  out << ")";
}


TDataNodeConfiguration::~TDataNodeConfiguration() noexcept {
}


void TDataNodeConfiguration::__set_location(const TDataNodeLocation& val) {
  this->location = val;
}

void TDataNodeConfiguration::__set_resource(const TNodeResource& val) {
  this->resource = val;
}
std::ostream& operator<<(std::ostream& out, const TDataNodeConfiguration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataNodeConfiguration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_location = false;
  bool isset_resource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource.read(iprot);
          isset_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDataNodeConfiguration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataNodeConfiguration");

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->location.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataNodeConfiguration &a, TDataNodeConfiguration &b) {
  using ::std::swap;
  swap(a.location, b.location);
  swap(a.resource, b.resource);
}

TDataNodeConfiguration::TDataNodeConfiguration(const TDataNodeConfiguration& other33) {
  location = other33.location;
  resource = other33.resource;
}
TDataNodeConfiguration& TDataNodeConfiguration::operator=(const TDataNodeConfiguration& other34) {
  location = other34.location;
  resource = other34.resource;
  return *this;
}
void TDataNodeConfiguration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataNodeConfiguration(";
  out << "location=" << to_string(location);
  out << ", " << "resource=" << to_string(resource);
  out << ")";
}


TAINodeConfiguration::~TAINodeConfiguration() noexcept {
}


void TAINodeConfiguration::__set_location(const TAINodeLocation& val) {
  this->location = val;
}

void TAINodeConfiguration::__set_resource(const TNodeResource& val) {
  this->resource = val;
}
std::ostream& operator<<(std::ostream& out, const TAINodeConfiguration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAINodeConfiguration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_location = false;
  bool isset_resource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource.read(iprot);
          isset_resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAINodeConfiguration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAINodeConfiguration");

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->location.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resource.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAINodeConfiguration &a, TAINodeConfiguration &b) {
  using ::std::swap;
  swap(a.location, b.location);
  swap(a.resource, b.resource);
}

TAINodeConfiguration::TAINodeConfiguration(const TAINodeConfiguration& other35) {
  location = other35.location;
  resource = other35.resource;
}
TAINodeConfiguration& TAINodeConfiguration::operator=(const TAINodeConfiguration& other36) {
  location = other36.location;
  resource = other36.resource;
  return *this;
}
void TAINodeConfiguration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAINodeConfiguration(";
  out << "location=" << to_string(location);
  out << ", " << "resource=" << to_string(resource);
  out << ")";
}


TFlushReq::~TFlushReq() noexcept {
}


void TFlushReq::__set_isSeq(const std::string& val) {
  this->isSeq = val;
__isset.isSeq = true;
}

void TFlushReq::__set_storageGroups(const std::vector<std::string> & val) {
  this->storageGroups = val;
__isset.storageGroups = true;
}

void TFlushReq::__set_regionIds(const std::vector<std::string> & val) {
  this->regionIds = val;
__isset.regionIds = true;
}
std::ostream& operator<<(std::ostream& out, const TFlushReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFlushReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->isSeq);
          this->__isset.isSeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->storageGroups.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->storageGroups.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readString(this->storageGroups[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.storageGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->regionIds.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->regionIds.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readString(this->regionIds[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.regionIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFlushReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFlushReq");

  if (this->__isset.isSeq) {
    xfer += oprot->writeFieldBegin("isSeq", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->isSeq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storageGroups) {
    xfer += oprot->writeFieldBegin("storageGroups", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->storageGroups.size()));
      std::vector<std::string> ::const_iterator _iter47;
      for (_iter47 = this->storageGroups.begin(); _iter47 != this->storageGroups.end(); ++_iter47)
      {
        xfer += oprot->writeString((*_iter47));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.regionIds) {
    xfer += oprot->writeFieldBegin("regionIds", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->regionIds.size()));
      std::vector<std::string> ::const_iterator _iter48;
      for (_iter48 = this->regionIds.begin(); _iter48 != this->regionIds.end(); ++_iter48)
      {
        xfer += oprot->writeString((*_iter48));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFlushReq &a, TFlushReq &b) {
  using ::std::swap;
  swap(a.isSeq, b.isSeq);
  swap(a.storageGroups, b.storageGroups);
  swap(a.regionIds, b.regionIds);
  swap(a.__isset, b.__isset);
}

TFlushReq::TFlushReq(const TFlushReq& other49) {
  isSeq = other49.isSeq;
  storageGroups = other49.storageGroups;
  regionIds = other49.regionIds;
  __isset = other49.__isset;
}
TFlushReq& TFlushReq::operator=(const TFlushReq& other50) {
  isSeq = other50.isSeq;
  storageGroups = other50.storageGroups;
  regionIds = other50.regionIds;
  __isset = other50.__isset;
  return *this;
}
void TFlushReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFlushReq(";
  out << "isSeq="; (__isset.isSeq ? (out << to_string(isSeq)) : (out << "<null>"));
  out << ", " << "storageGroups="; (__isset.storageGroups ? (out << to_string(storageGroups)) : (out << "<null>"));
  out << ", " << "regionIds="; (__isset.regionIds ? (out << to_string(regionIds)) : (out << "<null>"));
  out << ")";
}


TSettleReq::~TSettleReq() noexcept {
}


void TSettleReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}
std::ostream& operator<<(std::ostream& out, const TSettleReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSettleReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_paths = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->paths.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += iprot->readString(this->paths[_i55]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSettleReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSettleReq");

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter56;
    for (_iter56 = this->paths.begin(); _iter56 != this->paths.end(); ++_iter56)
    {
      xfer += oprot->writeString((*_iter56));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSettleReq &a, TSettleReq &b) {
  using ::std::swap;
  swap(a.paths, b.paths);
}

TSettleReq::TSettleReq(const TSettleReq& other57) {
  paths = other57.paths;
}
TSettleReq& TSettleReq::operator=(const TSettleReq& other58) {
  paths = other58.paths;
  return *this;
}
void TSettleReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSettleReq(";
  out << "paths=" << to_string(paths);
  out << ")";
}


TSchemaNode::~TSchemaNode() noexcept {
}


void TSchemaNode::__set_nodeName(const std::string& val) {
  this->nodeName = val;
}

void TSchemaNode::__set_nodeType(const int8_t val) {
  this->nodeType = val;
}
std::ostream& operator<<(std::ostream& out, const TSchemaNode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSchemaNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodeName = false;
  bool isset_nodeType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nodeName);
          isset_nodeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->nodeType);
          isset_nodeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nodeType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSchemaNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSchemaNode");

  xfer += oprot->writeFieldBegin("nodeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->nodeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->nodeType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSchemaNode &a, TSchemaNode &b) {
  using ::std::swap;
  swap(a.nodeName, b.nodeName);
  swap(a.nodeType, b.nodeType);
}

TSchemaNode::TSchemaNode(const TSchemaNode& other59) {
  nodeName = other59.nodeName;
  nodeType = other59.nodeType;
}
TSchemaNode& TSchemaNode::operator=(const TSchemaNode& other60) {
  nodeName = other60.nodeName;
  nodeType = other60.nodeType;
  return *this;
}
void TSchemaNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSchemaNode(";
  out << "nodeName=" << to_string(nodeName);
  out << ", " << "nodeType=" << to_string(nodeType);
  out << ")";
}


TSetConfigurationReq::~TSetConfigurationReq() noexcept {
}


void TSetConfigurationReq::__set_configs(const std::map<std::string, std::string> & val) {
  this->configs = val;
}

void TSetConfigurationReq::__set_nodeId(const int32_t val) {
  this->nodeId = val;
}
std::ostream& operator<<(std::ostream& out, const TSetConfigurationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSetConfigurationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_configs = false;
  bool isset_nodeId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configs.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              std::string _key66;
              xfer += iprot->readString(_key66);
              std::string& _val67 = this->configs[_key66];
              xfer += iprot->readString(_val67);
            }
            xfer += iprot->readMapEnd();
          }
          isset_configs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nodeId);
          isset_nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_configs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetConfigurationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetConfigurationReq");

  xfer += oprot->writeFieldBegin("configs", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configs.size()));
    std::map<std::string, std::string> ::const_iterator _iter68;
    for (_iter68 = this->configs.begin(); _iter68 != this->configs.end(); ++_iter68)
    {
      xfer += oprot->writeString(_iter68->first);
      xfer += oprot->writeString(_iter68->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetConfigurationReq &a, TSetConfigurationReq &b) {
  using ::std::swap;
  swap(a.configs, b.configs);
  swap(a.nodeId, b.nodeId);
}

TSetConfigurationReq::TSetConfigurationReq(const TSetConfigurationReq& other69) {
  configs = other69.configs;
  nodeId = other69.nodeId;
}
TSetConfigurationReq& TSetConfigurationReq::operator=(const TSetConfigurationReq& other70) {
  configs = other70.configs;
  nodeId = other70.nodeId;
  return *this;
}
void TSetConfigurationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetConfigurationReq(";
  out << "configs=" << to_string(configs);
  out << ", " << "nodeId=" << to_string(nodeId);
  out << ")";
}


TSetTTLReq::~TSetTTLReq() noexcept {
}


void TSetTTLReq::__set_pathPattern(const std::vector<std::string> & val) {
  this->pathPattern = val;
}

void TSetTTLReq::__set_TTL(const int64_t val) {
  this->TTL = val;
}

void TSetTTLReq::__set_isDataBase(const bool val) {
  this->isDataBase = val;
}
std::ostream& operator<<(std::ostream& out, const TSetTTLReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSetTTLReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pathPattern = false;
  bool isset_TTL = false;
  bool isset_isDataBase = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pathPattern.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->pathPattern.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readString(this->pathPattern[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          isset_pathPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->TTL);
          isset_TTL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDataBase);
          isset_isDataBase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pathPattern)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_TTL)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isDataBase)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetTTLReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetTTLReq");

  xfer += oprot->writeFieldBegin("pathPattern", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->pathPattern.size()));
    std::vector<std::string> ::const_iterator _iter76;
    for (_iter76 = this->pathPattern.begin(); _iter76 != this->pathPattern.end(); ++_iter76)
    {
      xfer += oprot->writeString((*_iter76));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TTL", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->TTL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isDataBase", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isDataBase);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetTTLReq &a, TSetTTLReq &b) {
  using ::std::swap;
  swap(a.pathPattern, b.pathPattern);
  swap(a.TTL, b.TTL);
  swap(a.isDataBase, b.isDataBase);
}

TSetTTLReq::TSetTTLReq(const TSetTTLReq& other77) {
  pathPattern = other77.pathPattern;
  TTL = other77.TTL;
  isDataBase = other77.isDataBase;
}
TSetTTLReq& TSetTTLReq::operator=(const TSetTTLReq& other78) {
  pathPattern = other78.pathPattern;
  TTL = other78.TTL;
  isDataBase = other78.isDataBase;
  return *this;
}
void TSetTTLReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetTTLReq(";
  out << "pathPattern=" << to_string(pathPattern);
  out << ", " << "TTL=" << to_string(TTL);
  out << ", " << "isDataBase=" << to_string(isDataBase);
  out << ")";
}


TShowTTLReq::~TShowTTLReq() noexcept {
}


void TShowTTLReq::__set_pathPattern(const std::vector<std::string> & val) {
  this->pathPattern = val;
}
std::ostream& operator<<(std::ostream& out, const TShowTTLReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TShowTTLReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pathPattern = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pathPattern.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->pathPattern.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readString(this->pathPattern[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          isset_pathPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pathPattern)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowTTLReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowTTLReq");

  xfer += oprot->writeFieldBegin("pathPattern", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->pathPattern.size()));
    std::vector<std::string> ::const_iterator _iter84;
    for (_iter84 = this->pathPattern.begin(); _iter84 != this->pathPattern.end(); ++_iter84)
    {
      xfer += oprot->writeString((*_iter84));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowTTLReq &a, TShowTTLReq &b) {
  using ::std::swap;
  swap(a.pathPattern, b.pathPattern);
}

TShowTTLReq::TShowTTLReq(const TShowTTLReq& other85) {
  pathPattern = other85.pathPattern;
}
TShowTTLReq& TShowTTLReq::operator=(const TShowTTLReq& other86) {
  pathPattern = other86.pathPattern;
  return *this;
}
void TShowTTLReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowTTLReq(";
  out << "pathPattern=" << to_string(pathPattern);
  out << ")";
}


TFile::~TFile() noexcept {
}


void TFile::__set_fileName(const std::string& val) {
  this->fileName = val;
}

void TFile::__set_file(const std::string& val) {
  this->file = val;
}
std::ostream& operator<<(std::ostream& out, const TFile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileName = false;
  bool isset_file = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fileName);
          isset_fileName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->file);
          isset_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFile");

  xfer += oprot->writeFieldBegin("fileName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fileName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->file);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFile &a, TFile &b) {
  using ::std::swap;
  swap(a.fileName, b.fileName);
  swap(a.file, b.file);
}

TFile::TFile(const TFile& other87) {
  fileName = other87.fileName;
  file = other87.file;
}
TFile& TFile::operator=(const TFile& other88) {
  fileName = other88.fileName;
  file = other88.file;
  return *this;
}
void TFile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFile(";
  out << "fileName=" << to_string(fileName);
  out << ", " << "file=" << to_string(file);
  out << ")";
}


TFilesResp::~TFilesResp() noexcept {
}


void TFilesResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TFilesResp::__set_files(const std::vector<TFile> & val) {
  this->files = val;
}
std::ostream& operator<<(std::ostream& out, const TFilesResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFilesResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_files = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->files.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += this->files[_i93].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_files)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TFilesResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFilesResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->files.size()));
    std::vector<TFile> ::const_iterator _iter94;
    for (_iter94 = this->files.begin(); _iter94 != this->files.end(); ++_iter94)
    {
      xfer += (*_iter94).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFilesResp &a, TFilesResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.files, b.files);
}

TFilesResp::TFilesResp(const TFilesResp& other95) {
  status = other95.status;
  files = other95.files;
}
TFilesResp& TFilesResp::operator=(const TFilesResp& other96) {
  status = other96.status;
  files = other96.files;
  return *this;
}
void TFilesResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFilesResp(";
  out << "status=" << to_string(status);
  out << ", " << "files=" << to_string(files);
  out << ")";
}


TSpaceQuota::~TSpaceQuota() noexcept {
}


void TSpaceQuota::__set_diskSize(const int64_t val) {
  this->diskSize = val;
__isset.diskSize = true;
}

void TSpaceQuota::__set_deviceNum(const int64_t val) {
  this->deviceNum = val;
__isset.deviceNum = true;
}

void TSpaceQuota::__set_timeserieNum(const int64_t val) {
  this->timeserieNum = val;
__isset.timeserieNum = true;
}
std::ostream& operator<<(std::ostream& out, const TSpaceQuota& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSpaceQuota::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->diskSize);
          this->__isset.diskSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deviceNum);
          this->__isset.deviceNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeserieNum);
          this->__isset.timeserieNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSpaceQuota::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSpaceQuota");

  if (this->__isset.diskSize) {
    xfer += oprot->writeFieldBegin("diskSize", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->diskSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deviceNum) {
    xfer += oprot->writeFieldBegin("deviceNum", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->deviceNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeserieNum) {
    xfer += oprot->writeFieldBegin("timeserieNum", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timeserieNum);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSpaceQuota &a, TSpaceQuota &b) {
  using ::std::swap;
  swap(a.diskSize, b.diskSize);
  swap(a.deviceNum, b.deviceNum);
  swap(a.timeserieNum, b.timeserieNum);
  swap(a.__isset, b.__isset);
}

TSpaceQuota::TSpaceQuota(const TSpaceQuota& other97) {
  diskSize = other97.diskSize;
  deviceNum = other97.deviceNum;
  timeserieNum = other97.timeserieNum;
  __isset = other97.__isset;
}
TSpaceQuota& TSpaceQuota::operator=(const TSpaceQuota& other98) {
  diskSize = other98.diskSize;
  deviceNum = other98.deviceNum;
  timeserieNum = other98.timeserieNum;
  __isset = other98.__isset;
  return *this;
}
void TSpaceQuota::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSpaceQuota(";
  out << "diskSize="; (__isset.diskSize ? (out << to_string(diskSize)) : (out << "<null>"));
  out << ", " << "deviceNum="; (__isset.deviceNum ? (out << to_string(deviceNum)) : (out << "<null>"));
  out << ", " << "timeserieNum="; (__isset.timeserieNum ? (out << to_string(timeserieNum)) : (out << "<null>"));
  out << ")";
}


TTimedQuota::~TTimedQuota() noexcept {
}


void TTimedQuota::__set_timeUnit(const int64_t val) {
  this->timeUnit = val;
}

void TTimedQuota::__set_softLimit(const int64_t val) {
  this->softLimit = val;
}
std::ostream& operator<<(std::ostream& out, const TTimedQuota& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTimedQuota::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timeUnit = false;
  bool isset_softLimit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeUnit);
          isset_timeUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->softLimit);
          isset_softLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timeUnit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_softLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimedQuota::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTimedQuota");

  xfer += oprot->writeFieldBegin("timeUnit", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timeUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("softLimit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->softLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTimedQuota &a, TTimedQuota &b) {
  using ::std::swap;
  swap(a.timeUnit, b.timeUnit);
  swap(a.softLimit, b.softLimit);
}

TTimedQuota::TTimedQuota(const TTimedQuota& other99) {
  timeUnit = other99.timeUnit;
  softLimit = other99.softLimit;
}
TTimedQuota& TTimedQuota::operator=(const TTimedQuota& other100) {
  timeUnit = other100.timeUnit;
  softLimit = other100.softLimit;
  return *this;
}
void TTimedQuota::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTimedQuota(";
  out << "timeUnit=" << to_string(timeUnit);
  out << ", " << "softLimit=" << to_string(softLimit);
  out << ")";
}


TThrottleQuota::~TThrottleQuota() noexcept {
}


void TThrottleQuota::__set_throttleLimit(const std::map<ThrottleType::type, TTimedQuota> & val) {
  this->throttleLimit = val;
__isset.throttleLimit = true;
}

void TThrottleQuota::__set_memLimit(const int64_t val) {
  this->memLimit = val;
__isset.memLimit = true;
}

void TThrottleQuota::__set_cpuLimit(const int32_t val) {
  this->cpuLimit = val;
__isset.cpuLimit = true;
}
std::ostream& operator<<(std::ostream& out, const TThrottleQuota& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TThrottleQuota::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->throttleLimit.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _ktype102;
            ::apache::thrift::protocol::TType _vtype103;
            xfer += iprot->readMapBegin(_ktype102, _vtype103, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              ThrottleType::type _key106;
              int32_t ecast108;
              xfer += iprot->readI32(ecast108);
              _key106 = (ThrottleType::type)ecast108;
              TTimedQuota& _val107 = this->throttleLimit[_key106];
              xfer += _val107.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.throttleLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memLimit);
          this->__isset.memLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cpuLimit);
          this->__isset.cpuLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TThrottleQuota::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TThrottleQuota");

  if (this->__isset.throttleLimit) {
    xfer += oprot->writeFieldBegin("throttleLimit", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->throttleLimit.size()));
      std::map<ThrottleType::type, TTimedQuota> ::const_iterator _iter109;
      for (_iter109 = this->throttleLimit.begin(); _iter109 != this->throttleLimit.end(); ++_iter109)
      {
        xfer += oprot->writeI32((int32_t)_iter109->first);
        xfer += _iter109->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memLimit) {
    xfer += oprot->writeFieldBegin("memLimit", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->memLimit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cpuLimit) {
    xfer += oprot->writeFieldBegin("cpuLimit", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->cpuLimit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TThrottleQuota &a, TThrottleQuota &b) {
  using ::std::swap;
  swap(a.throttleLimit, b.throttleLimit);
  swap(a.memLimit, b.memLimit);
  swap(a.cpuLimit, b.cpuLimit);
  swap(a.__isset, b.__isset);
}

TThrottleQuota::TThrottleQuota(const TThrottleQuota& other110) {
  throttleLimit = other110.throttleLimit;
  memLimit = other110.memLimit;
  cpuLimit = other110.cpuLimit;
  __isset = other110.__isset;
}
TThrottleQuota& TThrottleQuota::operator=(const TThrottleQuota& other111) {
  throttleLimit = other111.throttleLimit;
  memLimit = other111.memLimit;
  cpuLimit = other111.cpuLimit;
  __isset = other111.__isset;
  return *this;
}
void TThrottleQuota::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TThrottleQuota(";
  out << "throttleLimit="; (__isset.throttleLimit ? (out << to_string(throttleLimit)) : (out << "<null>"));
  out << ", " << "memLimit="; (__isset.memLimit ? (out << to_string(memLimit)) : (out << "<null>"));
  out << ", " << "cpuLimit="; (__isset.cpuLimit ? (out << to_string(cpuLimit)) : (out << "<null>"));
  out << ")";
}


TSetSpaceQuotaReq::~TSetSpaceQuotaReq() noexcept {
}


void TSetSpaceQuotaReq::__set_database(const std::vector<std::string> & val) {
  this->database = val;
}

void TSetSpaceQuotaReq::__set_spaceLimit(const TSpaceQuota& val) {
  this->spaceLimit = val;
}
std::ostream& operator<<(std::ostream& out, const TSetSpaceQuotaReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSetSpaceQuotaReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_database = false;
  bool isset_spaceLimit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->database.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->database.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += iprot->readString(this->database[_i116]);
            }
            xfer += iprot->readListEnd();
          }
          isset_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spaceLimit.read(iprot);
          isset_spaceLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_database)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_spaceLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetSpaceQuotaReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetSpaceQuotaReq");

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->database.size()));
    std::vector<std::string> ::const_iterator _iter117;
    for (_iter117 = this->database.begin(); _iter117 != this->database.end(); ++_iter117)
    {
      xfer += oprot->writeString((*_iter117));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spaceLimit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->spaceLimit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetSpaceQuotaReq &a, TSetSpaceQuotaReq &b) {
  using ::std::swap;
  swap(a.database, b.database);
  swap(a.spaceLimit, b.spaceLimit);
}

TSetSpaceQuotaReq::TSetSpaceQuotaReq(const TSetSpaceQuotaReq& other118) {
  database = other118.database;
  spaceLimit = other118.spaceLimit;
}
TSetSpaceQuotaReq& TSetSpaceQuotaReq::operator=(const TSetSpaceQuotaReq& other119) {
  database = other119.database;
  spaceLimit = other119.spaceLimit;
  return *this;
}
void TSetSpaceQuotaReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetSpaceQuotaReq(";
  out << "database=" << to_string(database);
  out << ", " << "spaceLimit=" << to_string(spaceLimit);
  out << ")";
}


TSetThrottleQuotaReq::~TSetThrottleQuotaReq() noexcept {
}


void TSetThrottleQuotaReq::__set_userName(const std::string& val) {
  this->userName = val;
}

void TSetThrottleQuotaReq::__set_throttleQuota(const TThrottleQuota& val) {
  this->throttleQuota = val;
}
std::ostream& operator<<(std::ostream& out, const TSetThrottleQuotaReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSetThrottleQuotaReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_userName = false;
  bool isset_throttleQuota = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          isset_userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->throttleQuota.read(iprot);
          isset_throttleQuota = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_userName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_throttleQuota)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSetThrottleQuotaReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetThrottleQuotaReq");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("throttleQuota", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->throttleQuota.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSetThrottleQuotaReq &a, TSetThrottleQuotaReq &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.throttleQuota, b.throttleQuota);
}

TSetThrottleQuotaReq::TSetThrottleQuotaReq(const TSetThrottleQuotaReq& other120) {
  userName = other120.userName;
  throttleQuota = other120.throttleQuota;
}
TSetThrottleQuotaReq& TSetThrottleQuotaReq::operator=(const TSetThrottleQuotaReq& other121) {
  userName = other121.userName;
  throttleQuota = other121.throttleQuota;
  return *this;
}
void TSetThrottleQuotaReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSetThrottleQuotaReq(";
  out << "userName=" << to_string(userName);
  out << ", " << "throttleQuota=" << to_string(throttleQuota);
  out << ")";
}


TLicense::~TLicense() noexcept {
}


void TLicense::__set_licenseIssueTimestamp(const int64_t val) {
  this->licenseIssueTimestamp = val;
}

void TLicense::__set_expireTimestamp(const int64_t val) {
  this->expireTimestamp = val;
}

void TLicense::__set_dataNodeNumLimit(const int16_t val) {
  this->dataNodeNumLimit = val;
}

void TLicense::__set_cpuCoreNumLimit(const int32_t val) {
  this->cpuCoreNumLimit = val;
}

void TLicense::__set_deviceNumLimit(const int64_t val) {
  this->deviceNumLimit = val;
}

void TLicense::__set_sensorNumLimit(const int64_t val) {
  this->sensorNumLimit = val;
}

void TLicense::__set_disconnectionFromActiveNodeTimeLimit(const int64_t val) {
  this->disconnectionFromActiveNodeTimeLimit = val;
}

void TLicense::__set_mlNodeNumLimit(const int16_t val) {
  this->mlNodeNumLimit = val;
}
std::ostream& operator<<(std::ostream& out, const TLicense& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLicense::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_licenseIssueTimestamp = false;
  bool isset_expireTimestamp = false;
  bool isset_dataNodeNumLimit = false;
  bool isset_cpuCoreNumLimit = false;
  bool isset_deviceNumLimit = false;
  bool isset_sensorNumLimit = false;
  bool isset_disconnectionFromActiveNodeTimeLimit = false;
  bool isset_mlNodeNumLimit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->licenseIssueTimestamp);
          isset_licenseIssueTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expireTimestamp);
          isset_expireTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->dataNodeNumLimit);
          isset_dataNodeNumLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cpuCoreNumLimit);
          isset_cpuCoreNumLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deviceNumLimit);
          isset_deviceNumLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sensorNumLimit);
          isset_sensorNumLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disconnectionFromActiveNodeTimeLimit);
          isset_disconnectionFromActiveNodeTimeLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mlNodeNumLimit);
          isset_mlNodeNumLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_licenseIssueTimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expireTimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataNodeNumLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cpuCoreNumLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceNumLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sensorNumLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_disconnectionFromActiveNodeTimeLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mlNodeNumLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLicense::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLicense");

  xfer += oprot->writeFieldBegin("licenseIssueTimestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->licenseIssueTimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expireTimestamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->expireTimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataNodeNumLimit", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->dataNodeNumLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpuCoreNumLimit", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->cpuCoreNumLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceNumLimit", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->deviceNumLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sensorNumLimit", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->sensorNumLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disconnectionFromActiveNodeTimeLimit", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->disconnectionFromActiveNodeTimeLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mlNodeNumLimit", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->mlNodeNumLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLicense &a, TLicense &b) {
  using ::std::swap;
  swap(a.licenseIssueTimestamp, b.licenseIssueTimestamp);
  swap(a.expireTimestamp, b.expireTimestamp);
  swap(a.dataNodeNumLimit, b.dataNodeNumLimit);
  swap(a.cpuCoreNumLimit, b.cpuCoreNumLimit);
  swap(a.deviceNumLimit, b.deviceNumLimit);
  swap(a.sensorNumLimit, b.sensorNumLimit);
  swap(a.disconnectionFromActiveNodeTimeLimit, b.disconnectionFromActiveNodeTimeLimit);
  swap(a.mlNodeNumLimit, b.mlNodeNumLimit);
}

TLicense::TLicense(const TLicense& other122) {
  licenseIssueTimestamp = other122.licenseIssueTimestamp;
  expireTimestamp = other122.expireTimestamp;
  dataNodeNumLimit = other122.dataNodeNumLimit;
  cpuCoreNumLimit = other122.cpuCoreNumLimit;
  deviceNumLimit = other122.deviceNumLimit;
  sensorNumLimit = other122.sensorNumLimit;
  disconnectionFromActiveNodeTimeLimit = other122.disconnectionFromActiveNodeTimeLimit;
  mlNodeNumLimit = other122.mlNodeNumLimit;
}
TLicense& TLicense::operator=(const TLicense& other123) {
  licenseIssueTimestamp = other123.licenseIssueTimestamp;
  expireTimestamp = other123.expireTimestamp;
  dataNodeNumLimit = other123.dataNodeNumLimit;
  cpuCoreNumLimit = other123.cpuCoreNumLimit;
  deviceNumLimit = other123.deviceNumLimit;
  sensorNumLimit = other123.sensorNumLimit;
  disconnectionFromActiveNodeTimeLimit = other123.disconnectionFromActiveNodeTimeLimit;
  mlNodeNumLimit = other123.mlNodeNumLimit;
  return *this;
}
void TLicense::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLicense(";
  out << "licenseIssueTimestamp=" << to_string(licenseIssueTimestamp);
  out << ", " << "expireTimestamp=" << to_string(expireTimestamp);
  out << ", " << "dataNodeNumLimit=" << to_string(dataNodeNumLimit);
  out << ", " << "cpuCoreNumLimit=" << to_string(cpuCoreNumLimit);
  out << ", " << "deviceNumLimit=" << to_string(deviceNumLimit);
  out << ", " << "sensorNumLimit=" << to_string(sensorNumLimit);
  out << ", " << "disconnectionFromActiveNodeTimeLimit=" << to_string(disconnectionFromActiveNodeTimeLimit);
  out << ", " << "mlNodeNumLimit=" << to_string(mlNodeNumLimit);
  out << ")";
}


TLoadSample::~TLoadSample() noexcept {
}


void TLoadSample::__set_cpuUsageRate(const double val) {
  this->cpuUsageRate = val;
}

void TLoadSample::__set_memoryUsageRate(const double val) {
  this->memoryUsageRate = val;
}

void TLoadSample::__set_diskUsageRate(const double val) {
  this->diskUsageRate = val;
}

void TLoadSample::__set_freeDiskSpace(const double val) {
  this->freeDiskSpace = val;
}
std::ostream& operator<<(std::ostream& out, const TLoadSample& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLoadSample::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cpuUsageRate = false;
  bool isset_memoryUsageRate = false;
  bool isset_diskUsageRate = false;
  bool isset_freeDiskSpace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cpuUsageRate);
          isset_cpuUsageRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->memoryUsageRate);
          isset_memoryUsageRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->diskUsageRate);
          isset_diskUsageRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->freeDiskSpace);
          isset_freeDiskSpace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cpuUsageRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_memoryUsageRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_diskUsageRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_freeDiskSpace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TLoadSample::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLoadSample");

  xfer += oprot->writeFieldBegin("cpuUsageRate", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->cpuUsageRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memoryUsageRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->memoryUsageRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("diskUsageRate", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->diskUsageRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeDiskSpace", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->freeDiskSpace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLoadSample &a, TLoadSample &b) {
  using ::std::swap;
  swap(a.cpuUsageRate, b.cpuUsageRate);
  swap(a.memoryUsageRate, b.memoryUsageRate);
  swap(a.diskUsageRate, b.diskUsageRate);
  swap(a.freeDiskSpace, b.freeDiskSpace);
}

TLoadSample::TLoadSample(const TLoadSample& other124) {
  cpuUsageRate = other124.cpuUsageRate;
  memoryUsageRate = other124.memoryUsageRate;
  diskUsageRate = other124.diskUsageRate;
  freeDiskSpace = other124.freeDiskSpace;
}
TLoadSample& TLoadSample::operator=(const TLoadSample& other125) {
  cpuUsageRate = other125.cpuUsageRate;
  memoryUsageRate = other125.memoryUsageRate;
  diskUsageRate = other125.diskUsageRate;
  freeDiskSpace = other125.freeDiskSpace;
  return *this;
}
void TLoadSample::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLoadSample(";
  out << "cpuUsageRate=" << to_string(cpuUsageRate);
  out << ", " << "memoryUsageRate=" << to_string(memoryUsageRate);
  out << ", " << "diskUsageRate=" << to_string(diskUsageRate);
  out << ", " << "freeDiskSpace=" << to_string(freeDiskSpace);
  out << ")";
}


TServiceProvider::~TServiceProvider() noexcept {
}


void TServiceProvider::__set_endPoint(const TEndPoint& val) {
  this->endPoint = val;
}

void TServiceProvider::__set_serviceType(const TServiceType::type val) {
  this->serviceType = val;
}

void TServiceProvider::__set_nodeId(const int32_t val) {
  this->nodeId = val;
}
std::ostream& operator<<(std::ostream& out, const TServiceProvider& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServiceProvider::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_endPoint = false;
  bool isset_serviceType = false;
  bool isset_nodeId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->endPoint.read(iprot);
          isset_endPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast126;
          xfer += iprot->readI32(ecast126);
          this->serviceType = (TServiceType::type)ecast126;
          isset_serviceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nodeId);
          isset_nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_endPoint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serviceType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TServiceProvider::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServiceProvider");

  xfer += oprot->writeFieldBegin("endPoint", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->endPoint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serviceType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->serviceType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServiceProvider &a, TServiceProvider &b) {
  using ::std::swap;
  swap(a.endPoint, b.endPoint);
  swap(a.serviceType, b.serviceType);
  swap(a.nodeId, b.nodeId);
}

TServiceProvider::TServiceProvider(const TServiceProvider& other127) {
  endPoint = other127.endPoint;
  serviceType = other127.serviceType;
  nodeId = other127.nodeId;
}
TServiceProvider& TServiceProvider::operator=(const TServiceProvider& other128) {
  endPoint = other128.endPoint;
  serviceType = other128.serviceType;
  nodeId = other128.nodeId;
  return *this;
}
void TServiceProvider::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServiceProvider(";
  out << "endPoint=" << to_string(endPoint);
  out << ", " << "serviceType=" << to_string(serviceType);
  out << ", " << "nodeId=" << to_string(nodeId);
  out << ")";
}


TSender::~TSender() noexcept {
}


void TSender::__set_dataNodeLocation(const TDataNodeLocation& val) {
  this->dataNodeLocation = val;
__isset.dataNodeLocation = true;
}

void TSender::__set_configNodeLocation(const TConfigNodeLocation& val) {
  this->configNodeLocation = val;
__isset.configNodeLocation = true;
}
std::ostream& operator<<(std::ostream& out, const TSender& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSender::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataNodeLocation.read(iprot);
          this->__isset.dataNodeLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->configNodeLocation.read(iprot);
          this->__isset.configNodeLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSender::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSender");

  if (this->__isset.dataNodeLocation) {
    xfer += oprot->writeFieldBegin("dataNodeLocation", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->dataNodeLocation.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configNodeLocation) {
    xfer += oprot->writeFieldBegin("configNodeLocation", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->configNodeLocation.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSender &a, TSender &b) {
  using ::std::swap;
  swap(a.dataNodeLocation, b.dataNodeLocation);
  swap(a.configNodeLocation, b.configNodeLocation);
  swap(a.__isset, b.__isset);
}

TSender::TSender(const TSender& other129) {
  dataNodeLocation = other129.dataNodeLocation;
  configNodeLocation = other129.configNodeLocation;
  __isset = other129.__isset;
}
TSender& TSender::operator=(const TSender& other130) {
  dataNodeLocation = other130.dataNodeLocation;
  configNodeLocation = other130.configNodeLocation;
  __isset = other130.__isset;
  return *this;
}
void TSender::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSender(";
  out << "dataNodeLocation="; (__isset.dataNodeLocation ? (out << to_string(dataNodeLocation)) : (out << "<null>"));
  out << ", " << "configNodeLocation="; (__isset.configNodeLocation ? (out << to_string(configNodeLocation)) : (out << "<null>"));
  out << ")";
}


TTestConnectionResult::~TTestConnectionResult() noexcept {
}


void TTestConnectionResult::__set_serviceProvider(const TServiceProvider& val) {
  this->serviceProvider = val;
}

void TTestConnectionResult::__set_sender(const TSender& val) {
  this->sender = val;
}

void TTestConnectionResult::__set_success(const bool val) {
  this->success = val;
}

void TTestConnectionResult::__set_reason(const std::string& val) {
  this->reason = val;
__isset.reason = true;
}
std::ostream& operator<<(std::ostream& out, const TTestConnectionResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTestConnectionResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serviceProvider = false;
  bool isset_sender = false;
  bool isset_success = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serviceProvider.read(iprot);
          isset_serviceProvider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sender.read(iprot);
          isset_sender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          isset_success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serviceProvider)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sender)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTestConnectionResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTestConnectionResult");

  xfer += oprot->writeFieldBegin("serviceProvider", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serviceProvider.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sender", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sender.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.reason) {
    xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->reason);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTestConnectionResult &a, TTestConnectionResult &b) {
  using ::std::swap;
  swap(a.serviceProvider, b.serviceProvider);
  swap(a.sender, b.sender);
  swap(a.success, b.success);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

TTestConnectionResult::TTestConnectionResult(const TTestConnectionResult& other131) {
  serviceProvider = other131.serviceProvider;
  sender = other131.sender;
  success = other131.success;
  reason = other131.reason;
  __isset = other131.__isset;
}
TTestConnectionResult& TTestConnectionResult::operator=(const TTestConnectionResult& other132) {
  serviceProvider = other132.serviceProvider;
  sender = other132.sender;
  success = other132.success;
  reason = other132.reason;
  __isset = other132.__isset;
  return *this;
}
void TTestConnectionResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTestConnectionResult(";
  out << "serviceProvider=" << to_string(serviceProvider);
  out << ", " << "sender=" << to_string(sender);
  out << ", " << "success=" << to_string(success);
  out << ", " << "reason="; (__isset.reason ? (out << to_string(reason)) : (out << "<null>"));
  out << ")";
}


TTestConnectionResp::~TTestConnectionResp() noexcept {
}


void TTestConnectionResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TTestConnectionResp::__set_resultList(const std::vector<TTestConnectionResult> & val) {
  this->resultList = val;
}
std::ostream& operator<<(std::ostream& out, const TTestConnectionResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTestConnectionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_resultList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resultList.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->resultList.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += this->resultList[_i137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_resultList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resultList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTestConnectionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTestConnectionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resultList.size()));
    std::vector<TTestConnectionResult> ::const_iterator _iter138;
    for (_iter138 = this->resultList.begin(); _iter138 != this->resultList.end(); ++_iter138)
    {
      xfer += (*_iter138).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTestConnectionResp &a, TTestConnectionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.resultList, b.resultList);
}

TTestConnectionResp::TTestConnectionResp(const TTestConnectionResp& other139) {
  status = other139.status;
  resultList = other139.resultList;
}
TTestConnectionResp& TTestConnectionResp::operator=(const TTestConnectionResp& other140) {
  status = other140.status;
  resultList = other140.resultList;
  return *this;
}
void TTestConnectionResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTestConnectionResp(";
  out << "status=" << to_string(status);
  out << ", " << "resultList=" << to_string(resultList);
  out << ")";
}


TNodeLocations::~TNodeLocations() noexcept {
}


void TNodeLocations::__set_configNodeLocations(const std::vector<TConfigNodeLocation> & val) {
  this->configNodeLocations = val;
__isset.configNodeLocations = true;
}

void TNodeLocations::__set_dataNodeLocations(const std::vector<TDataNodeLocation> & val) {
  this->dataNodeLocations = val;
__isset.dataNodeLocations = true;
}
std::ostream& operator<<(std::ostream& out, const TNodeLocations& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeLocations::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->configNodeLocations.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->configNodeLocations.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += this->configNodeLocations[_i145].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.configNodeLocations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataNodeLocations.clear();
            uint32_t _size146;
            ::apache::thrift::protocol::TType _etype149;
            xfer += iprot->readListBegin(_etype149, _size146);
            this->dataNodeLocations.resize(_size146);
            uint32_t _i150;
            for (_i150 = 0; _i150 < _size146; ++_i150)
            {
              xfer += this->dataNodeLocations[_i150].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataNodeLocations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TNodeLocations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeLocations");

  if (this->__isset.configNodeLocations) {
    xfer += oprot->writeFieldBegin("configNodeLocations", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->configNodeLocations.size()));
      std::vector<TConfigNodeLocation> ::const_iterator _iter151;
      for (_iter151 = this->configNodeLocations.begin(); _iter151 != this->configNodeLocations.end(); ++_iter151)
      {
        xfer += (*_iter151).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataNodeLocations) {
    xfer += oprot->writeFieldBegin("dataNodeLocations", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataNodeLocations.size()));
      std::vector<TDataNodeLocation> ::const_iterator _iter152;
      for (_iter152 = this->dataNodeLocations.begin(); _iter152 != this->dataNodeLocations.end(); ++_iter152)
      {
        xfer += (*_iter152).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeLocations &a, TNodeLocations &b) {
  using ::std::swap;
  swap(a.configNodeLocations, b.configNodeLocations);
  swap(a.dataNodeLocations, b.dataNodeLocations);
  swap(a.__isset, b.__isset);
}

TNodeLocations::TNodeLocations(const TNodeLocations& other153) {
  configNodeLocations = other153.configNodeLocations;
  dataNodeLocations = other153.dataNodeLocations;
  __isset = other153.__isset;
}
TNodeLocations& TNodeLocations::operator=(const TNodeLocations& other154) {
  configNodeLocations = other154.configNodeLocations;
  dataNodeLocations = other154.dataNodeLocations;
  __isset = other154.__isset;
  return *this;
}
void TNodeLocations::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeLocations(";
  out << "configNodeLocations="; (__isset.configNodeLocations ? (out << to_string(configNodeLocations)) : (out << "<null>"));
  out << ", " << "dataNodeLocations="; (__isset.dataNodeLocations ? (out << to_string(dataNodeLocations)) : (out << "<null>"));
  out << ")";
}


TShowConfigurationTemplateResp::~TShowConfigurationTemplateResp() noexcept {
}


void TShowConfigurationTemplateResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TShowConfigurationTemplateResp::__set_content(const std::string& val) {
  this->content = val;
}
std::ostream& operator<<(std::ostream& out, const TShowConfigurationTemplateResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TShowConfigurationTemplateResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_content = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          isset_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_content)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowConfigurationTemplateResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowConfigurationTemplateResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowConfigurationTemplateResp &a, TShowConfigurationTemplateResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.content, b.content);
}

TShowConfigurationTemplateResp::TShowConfigurationTemplateResp(const TShowConfigurationTemplateResp& other155) {
  status = other155.status;
  content = other155.content;
}
TShowConfigurationTemplateResp& TShowConfigurationTemplateResp::operator=(const TShowConfigurationTemplateResp& other156) {
  status = other156.status;
  content = other156.content;
  return *this;
}
void TShowConfigurationTemplateResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowConfigurationTemplateResp(";
  out << "status=" << to_string(status);
  out << ", " << "content=" << to_string(content);
  out << ")";
}


TShowConfigurationResp::~TShowConfigurationResp() noexcept {
}


void TShowConfigurationResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TShowConfigurationResp::__set_content(const std::string& val) {
  this->content = val;
}
std::ostream& operator<<(std::ostream& out, const TShowConfigurationResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TShowConfigurationResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_content = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          isset_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_content)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TShowConfigurationResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowConfigurationResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TShowConfigurationResp &a, TShowConfigurationResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.content, b.content);
}

TShowConfigurationResp::TShowConfigurationResp(const TShowConfigurationResp& other157) {
  status = other157.status;
  content = other157.content;
}
TShowConfigurationResp& TShowConfigurationResp::operator=(const TShowConfigurationResp& other158) {
  status = other158.status;
  content = other158.content;
  return *this;
}
void TShowConfigurationResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TShowConfigurationResp(";
  out << "status=" << to_string(status);
  out << ", " << "content=" << to_string(content);
  out << ")";
}


