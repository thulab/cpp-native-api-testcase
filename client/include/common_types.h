/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef common_TYPES_H
#define common_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>




struct TConsensusGroupType {
  enum type {
    ConfigRegion = 0,
    DataRegion = 1,
    SchemaRegion = 2
  };
};

extern const std::map<int, const char*> _TConsensusGroupType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TConsensusGroupType::type& val);

std::string to_string(const TConsensusGroupType::type& val);

struct TRegionMigrateFailedType {
  enum type {
    AddPeerFailed = 0,
    RemovePeerFailed = 1,
    RemoveConsensusGroupFailed = 2,
    DeleteRegionFailed = 3,
    CreateRegionFailed = 4,
    Disconnect = 5
  };
};

extern const std::map<int, const char*> _TRegionMigrateFailedType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRegionMigrateFailedType::type& val);

std::string to_string(const TRegionMigrateFailedType::type& val);

struct TRegionMaintainTaskStatus {
  enum type {
    TASK_NOT_EXIST = 0,
    PROCESSING = 1,
    SUCCESS = 2,
    FAIL = 3
  };
};

extern const std::map<int, const char*> _TRegionMaintainTaskStatus_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRegionMaintainTaskStatus::type& val);

std::string to_string(const TRegionMaintainTaskStatus::type& val);

struct ThrottleType {
  enum type {
    REQUEST_NUMBER = 0,
    REQUEST_SIZE = 1,
    WRITE_NUMBER = 2,
    WRITE_SIZE = 3,
    READ_NUMBER = 4,
    READ_SIZE = 5
  };
};

extern const std::map<int, const char*> _ThrottleType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ThrottleType::type& val);

std::string to_string(const ThrottleType::type& val);

struct TServiceType {
  enum type {
    ConfigNodeInternalService = 0,
    DataNodeInternalService = 1,
    DataNodeMPPService = 2,
    DataNodeExternalService = 3
  };
};

extern const std::map<int, const char*> _TServiceType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TServiceType::type& val);

std::string to_string(const TServiceType::type& val);

struct TAggregationType {
  enum type {
    COUNT = 0,
    AVG = 1,
    SUM = 2,
    FIRST_VALUE = 3,
    LAST_VALUE = 4,
    MAX_TIME = 5,
    MIN_TIME = 6,
    MAX_VALUE = 7,
    MIN_VALUE = 8,
    EXTREME = 9,
    COUNT_IF = 10,
    TIME_DURATION = 11,
    MODE = 12,
    COUNT_TIME = 13,
    STDDEV = 14,
    STDDEV_POP = 15,
    STDDEV_SAMP = 16,
    VARIANCE = 17,
    VAR_POP = 18,
    VAR_SAMP = 19,
    MAX_BY = 20,
    MIN_BY = 21,
    UDAF = 22,
    FIRST = 23,
    LAST = 24,
    FIRST_BY = 25,
    LAST_BY = 26,
    MIN = 27,
    MAX = 28,
    COUNT_ALL = 29,
    APPROX_COUNT_DISTINCT = 30,
    APPROX_MOST_FREQUENT = 31
  };
};

extern const std::map<int, const char*> _TAggregationType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAggregationType::type& val);

std::string to_string(const TAggregationType::type& val);

struct TrainingState {
  enum type {
    PENDING = 0,
    RUNNING = 1,
    FINISHED = 2,
    FAILED = 3,
    DROPPING = 4
  };
};

extern const std::map<int, const char*> _TrainingState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TrainingState::type& val);

std::string to_string(const TrainingState::type& val);

struct Model {
  enum type {
    TREE = 0,
    TABLE = 1
  };
};

extern const std::map<int, const char*> _Model_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Model::type& val);

std::string to_string(const Model::type& val);

struct FunctionType {
  enum type {
    NONE = 0,
    SCALAR = 1,
    AGGREGATE = 2,
    TABLE = 3
  };
};

extern const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FunctionType::type& val);

std::string to_string(const FunctionType::type& val);

class TEndPoint;

class TSStatus;

class TConsensusGroupId;

class TSeriesPartitionSlot;

class TTimePartitionSlot;

class TRegionReplicaSet;

class TNodeResource;

class TConfigNodeLocation;

class TDataNodeLocation;

class TAINodeLocation;

class TDataNodeConfiguration;

class TAINodeConfiguration;

class TFlushReq;

class TSettleReq;

class TSchemaNode;

class TSetConfigurationReq;

class TSetTTLReq;

class TShowTTLReq;

class TFile;

class TFilesResp;

class TSpaceQuota;

class TTimedQuota;

class TThrottleQuota;

class TSetSpaceQuotaReq;

class TSetThrottleQuotaReq;

class TLicense;

class TLoadSample;

class TServiceProvider;

class TSender;

class TTestConnectionResult;

class TTestConnectionResp;

class TNodeLocations;

class TShowConfigurationTemplateResp;

class TShowConfigurationResp;


class TEndPoint : public virtual ::apache::thrift::TBase {
 public:

  TEndPoint(const TEndPoint&);
  TEndPoint& operator=(const TEndPoint&);
  TEndPoint() : ip(), port(0) {
  }

  virtual ~TEndPoint() noexcept;
  std::string ip;
  int32_t port;

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const TEndPoint & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const TEndPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEndPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEndPoint &a, TEndPoint &b);

std::ostream& operator<<(std::ostream& out, const TEndPoint& obj);

typedef struct _TSStatus__isset {
  _TSStatus__isset() : message(false), subStatus(false), redirectNode(false), needRetry(false) {}
  bool message :1;
  bool subStatus :1;
  bool redirectNode :1;
  bool needRetry :1;
} _TSStatus__isset;

class TSStatus : public virtual ::apache::thrift::TBase {
 public:

  TSStatus(const TSStatus&);
  TSStatus& operator=(const TSStatus&);
  TSStatus() : code(0), message(), needRetry(0) {
  }

  virtual ~TSStatus() noexcept;
  int32_t code;
  std::string message;
  std::vector<TSStatus>  subStatus;
  TEndPoint redirectNode;
  bool needRetry;

  _TSStatus__isset __isset;

  void __set_code(const int32_t val);

  void __set_message(const std::string& val);

  void __set_subStatus(const std::vector<TSStatus> & val);

  void __set_redirectNode(const TEndPoint& val);

  void __set_needRetry(const bool val);

  bool operator == (const TSStatus & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.subStatus != rhs.__isset.subStatus)
      return false;
    else if (__isset.subStatus && !(subStatus == rhs.subStatus))
      return false;
    if (__isset.redirectNode != rhs.__isset.redirectNode)
      return false;
    else if (__isset.redirectNode && !(redirectNode == rhs.redirectNode))
      return false;
    if (__isset.needRetry != rhs.__isset.needRetry)
      return false;
    else if (__isset.needRetry && !(needRetry == rhs.needRetry))
      return false;
    return true;
  }
  bool operator != (const TSStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSStatus &a, TSStatus &b);

std::ostream& operator<<(std::ostream& out, const TSStatus& obj);


class TConsensusGroupId : public virtual ::apache::thrift::TBase {
 public:

  TConsensusGroupId(const TConsensusGroupId&);
  TConsensusGroupId& operator=(const TConsensusGroupId&);
  TConsensusGroupId() : type((TConsensusGroupType::type)0), id(0) {
  }

  virtual ~TConsensusGroupId() noexcept;
  /**
   * 
   * @see TConsensusGroupType
   */
  TConsensusGroupType::type type;
  int32_t id;

  void __set_type(const TConsensusGroupType::type val);

  void __set_id(const int32_t val);

  bool operator == (const TConsensusGroupId & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TConsensusGroupId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TConsensusGroupId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TConsensusGroupId &a, TConsensusGroupId &b);

std::ostream& operator<<(std::ostream& out, const TConsensusGroupId& obj);


class TSeriesPartitionSlot : public virtual ::apache::thrift::TBase {
 public:

  TSeriesPartitionSlot(const TSeriesPartitionSlot&);
  TSeriesPartitionSlot& operator=(const TSeriesPartitionSlot&);
  TSeriesPartitionSlot() : slotId(0) {
  }

  virtual ~TSeriesPartitionSlot() noexcept;
  int32_t slotId;

  void __set_slotId(const int32_t val);

  bool operator == (const TSeriesPartitionSlot & rhs) const
  {
    if (!(slotId == rhs.slotId))
      return false;
    return true;
  }
  bool operator != (const TSeriesPartitionSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSeriesPartitionSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSeriesPartitionSlot &a, TSeriesPartitionSlot &b);

std::ostream& operator<<(std::ostream& out, const TSeriesPartitionSlot& obj);


class TTimePartitionSlot : public virtual ::apache::thrift::TBase {
 public:

  TTimePartitionSlot(const TTimePartitionSlot&);
  TTimePartitionSlot& operator=(const TTimePartitionSlot&);
  TTimePartitionSlot() : startTime(0) {
  }

  virtual ~TTimePartitionSlot() noexcept;
  int64_t startTime;

  void __set_startTime(const int64_t val);

  bool operator == (const TTimePartitionSlot & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    return true;
  }
  bool operator != (const TTimePartitionSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTimePartitionSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTimePartitionSlot &a, TTimePartitionSlot &b);

std::ostream& operator<<(std::ostream& out, const TTimePartitionSlot& obj);


class TRegionReplicaSet : public virtual ::apache::thrift::TBase {
 public:

  TRegionReplicaSet(const TRegionReplicaSet&);
  TRegionReplicaSet& operator=(const TRegionReplicaSet&);
  TRegionReplicaSet() {
  }

  virtual ~TRegionReplicaSet() noexcept;
  TConsensusGroupId regionId;
  std::vector<TDataNodeLocation>  dataNodeLocations;

  void __set_regionId(const TConsensusGroupId& val);

  void __set_dataNodeLocations(const std::vector<TDataNodeLocation> & val);

  bool operator == (const TRegionReplicaSet & rhs) const
  {
    if (!(regionId == rhs.regionId))
      return false;
    if (!(dataNodeLocations == rhs.dataNodeLocations))
      return false;
    return true;
  }
  bool operator != (const TRegionReplicaSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRegionReplicaSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRegionReplicaSet &a, TRegionReplicaSet &b);

std::ostream& operator<<(std::ostream& out, const TRegionReplicaSet& obj);


class TNodeResource : public virtual ::apache::thrift::TBase {
 public:

  TNodeResource(const TNodeResource&);
  TNodeResource& operator=(const TNodeResource&);
  TNodeResource() : cpuCoreNum(0), maxMemory(0) {
  }

  virtual ~TNodeResource() noexcept;
  int32_t cpuCoreNum;
  int64_t maxMemory;

  void __set_cpuCoreNum(const int32_t val);

  void __set_maxMemory(const int64_t val);

  bool operator == (const TNodeResource & rhs) const
  {
    if (!(cpuCoreNum == rhs.cpuCoreNum))
      return false;
    if (!(maxMemory == rhs.maxMemory))
      return false;
    return true;
  }
  bool operator != (const TNodeResource &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNodeResource & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNodeResource &a, TNodeResource &b);

std::ostream& operator<<(std::ostream& out, const TNodeResource& obj);


class TConfigNodeLocation : public virtual ::apache::thrift::TBase {
 public:

  TConfigNodeLocation(const TConfigNodeLocation&);
  TConfigNodeLocation& operator=(const TConfigNodeLocation&);
  TConfigNodeLocation() : configNodeId(0) {
  }

  virtual ~TConfigNodeLocation() noexcept;
  int32_t configNodeId;
  TEndPoint internalEndPoint;
  TEndPoint consensusEndPoint;

  void __set_configNodeId(const int32_t val);

  void __set_internalEndPoint(const TEndPoint& val);

  void __set_consensusEndPoint(const TEndPoint& val);

  bool operator == (const TConfigNodeLocation & rhs) const
  {
    if (!(configNodeId == rhs.configNodeId))
      return false;
    if (!(internalEndPoint == rhs.internalEndPoint))
      return false;
    if (!(consensusEndPoint == rhs.consensusEndPoint))
      return false;
    return true;
  }
  bool operator != (const TConfigNodeLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TConfigNodeLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TConfigNodeLocation &a, TConfigNodeLocation &b);

std::ostream& operator<<(std::ostream& out, const TConfigNodeLocation& obj);


class TDataNodeLocation : public virtual ::apache::thrift::TBase {
 public:

  TDataNodeLocation(const TDataNodeLocation&);
  TDataNodeLocation& operator=(const TDataNodeLocation&);
  TDataNodeLocation() : dataNodeId(0) {
  }

  virtual ~TDataNodeLocation() noexcept;
  int32_t dataNodeId;
  TEndPoint clientRpcEndPoint;
  TEndPoint internalEndPoint;
  TEndPoint mPPDataExchangeEndPoint;
  TEndPoint dataRegionConsensusEndPoint;
  TEndPoint schemaRegionConsensusEndPoint;

  void __set_dataNodeId(const int32_t val);

  void __set_clientRpcEndPoint(const TEndPoint& val);

  void __set_internalEndPoint(const TEndPoint& val);

  void __set_mPPDataExchangeEndPoint(const TEndPoint& val);

  void __set_dataRegionConsensusEndPoint(const TEndPoint& val);

  void __set_schemaRegionConsensusEndPoint(const TEndPoint& val);

  bool operator == (const TDataNodeLocation & rhs) const
  {
    if (!(dataNodeId == rhs.dataNodeId))
      return false;
    if (!(clientRpcEndPoint == rhs.clientRpcEndPoint))
      return false;
    if (!(internalEndPoint == rhs.internalEndPoint))
      return false;
    if (!(mPPDataExchangeEndPoint == rhs.mPPDataExchangeEndPoint))
      return false;
    if (!(dataRegionConsensusEndPoint == rhs.dataRegionConsensusEndPoint))
      return false;
    if (!(schemaRegionConsensusEndPoint == rhs.schemaRegionConsensusEndPoint))
      return false;
    return true;
  }
  bool operator != (const TDataNodeLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataNodeLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataNodeLocation &a, TDataNodeLocation &b);

std::ostream& operator<<(std::ostream& out, const TDataNodeLocation& obj);


class TAINodeLocation : public virtual ::apache::thrift::TBase {
 public:

  TAINodeLocation(const TAINodeLocation&);
  TAINodeLocation& operator=(const TAINodeLocation&);
  TAINodeLocation() : aiNodeId(0) {
  }

  virtual ~TAINodeLocation() noexcept;
  int32_t aiNodeId;
  TEndPoint internalEndPoint;

  void __set_aiNodeId(const int32_t val);

  void __set_internalEndPoint(const TEndPoint& val);

  bool operator == (const TAINodeLocation & rhs) const
  {
    if (!(aiNodeId == rhs.aiNodeId))
      return false;
    if (!(internalEndPoint == rhs.internalEndPoint))
      return false;
    return true;
  }
  bool operator != (const TAINodeLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAINodeLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAINodeLocation &a, TAINodeLocation &b);

std::ostream& operator<<(std::ostream& out, const TAINodeLocation& obj);


class TDataNodeConfiguration : public virtual ::apache::thrift::TBase {
 public:

  TDataNodeConfiguration(const TDataNodeConfiguration&);
  TDataNodeConfiguration& operator=(const TDataNodeConfiguration&);
  TDataNodeConfiguration() {
  }

  virtual ~TDataNodeConfiguration() noexcept;
  TDataNodeLocation location;
  TNodeResource resource;

  void __set_location(const TDataNodeLocation& val);

  void __set_resource(const TNodeResource& val);

  bool operator == (const TDataNodeConfiguration & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (!(resource == rhs.resource))
      return false;
    return true;
  }
  bool operator != (const TDataNodeConfiguration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataNodeConfiguration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataNodeConfiguration &a, TDataNodeConfiguration &b);

std::ostream& operator<<(std::ostream& out, const TDataNodeConfiguration& obj);


class TAINodeConfiguration : public virtual ::apache::thrift::TBase {
 public:

  TAINodeConfiguration(const TAINodeConfiguration&);
  TAINodeConfiguration& operator=(const TAINodeConfiguration&);
  TAINodeConfiguration() {
  }

  virtual ~TAINodeConfiguration() noexcept;
  TAINodeLocation location;
  TNodeResource resource;

  void __set_location(const TAINodeLocation& val);

  void __set_resource(const TNodeResource& val);

  bool operator == (const TAINodeConfiguration & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (!(resource == rhs.resource))
      return false;
    return true;
  }
  bool operator != (const TAINodeConfiguration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAINodeConfiguration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAINodeConfiguration &a, TAINodeConfiguration &b);

std::ostream& operator<<(std::ostream& out, const TAINodeConfiguration& obj);

typedef struct _TFlushReq__isset {
  _TFlushReq__isset() : isSeq(false), storageGroups(false), regionIds(false) {}
  bool isSeq :1;
  bool storageGroups :1;
  bool regionIds :1;
} _TFlushReq__isset;

class TFlushReq : public virtual ::apache::thrift::TBase {
 public:

  TFlushReq(const TFlushReq&);
  TFlushReq& operator=(const TFlushReq&);
  TFlushReq() : isSeq() {
  }

  virtual ~TFlushReq() noexcept;
  std::string isSeq;
  std::vector<std::string>  storageGroups;
  std::vector<std::string>  regionIds;

  _TFlushReq__isset __isset;

  void __set_isSeq(const std::string& val);

  void __set_storageGroups(const std::vector<std::string> & val);

  void __set_regionIds(const std::vector<std::string> & val);

  bool operator == (const TFlushReq & rhs) const
  {
    if (__isset.isSeq != rhs.__isset.isSeq)
      return false;
    else if (__isset.isSeq && !(isSeq == rhs.isSeq))
      return false;
    if (__isset.storageGroups != rhs.__isset.storageGroups)
      return false;
    else if (__isset.storageGroups && !(storageGroups == rhs.storageGroups))
      return false;
    if (__isset.regionIds != rhs.__isset.regionIds)
      return false;
    else if (__isset.regionIds && !(regionIds == rhs.regionIds))
      return false;
    return true;
  }
  bool operator != (const TFlushReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFlushReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFlushReq &a, TFlushReq &b);

std::ostream& operator<<(std::ostream& out, const TFlushReq& obj);


class TSettleReq : public virtual ::apache::thrift::TBase {
 public:

  TSettleReq(const TSettleReq&);
  TSettleReq& operator=(const TSettleReq&);
  TSettleReq() {
  }

  virtual ~TSettleReq() noexcept;
  std::vector<std::string>  paths;

  void __set_paths(const std::vector<std::string> & val);

  bool operator == (const TSettleReq & rhs) const
  {
    if (!(paths == rhs.paths))
      return false;
    return true;
  }
  bool operator != (const TSettleReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSettleReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSettleReq &a, TSettleReq &b);

std::ostream& operator<<(std::ostream& out, const TSettleReq& obj);


class TSchemaNode : public virtual ::apache::thrift::TBase {
 public:

  TSchemaNode(const TSchemaNode&);
  TSchemaNode& operator=(const TSchemaNode&);
  TSchemaNode() : nodeName(), nodeType(0) {
  }

  virtual ~TSchemaNode() noexcept;
  std::string nodeName;
  int8_t nodeType;

  void __set_nodeName(const std::string& val);

  void __set_nodeType(const int8_t val);

  bool operator == (const TSchemaNode & rhs) const
  {
    if (!(nodeName == rhs.nodeName))
      return false;
    if (!(nodeType == rhs.nodeType))
      return false;
    return true;
  }
  bool operator != (const TSchemaNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSchemaNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSchemaNode &a, TSchemaNode &b);

std::ostream& operator<<(std::ostream& out, const TSchemaNode& obj);


class TSetConfigurationReq : public virtual ::apache::thrift::TBase {
 public:

  TSetConfigurationReq(const TSetConfigurationReq&);
  TSetConfigurationReq& operator=(const TSetConfigurationReq&);
  TSetConfigurationReq() : nodeId(0) {
  }

  virtual ~TSetConfigurationReq() noexcept;
  std::map<std::string, std::string>  configs;
  int32_t nodeId;

  void __set_configs(const std::map<std::string, std::string> & val);

  void __set_nodeId(const int32_t val);

  bool operator == (const TSetConfigurationReq & rhs) const
  {
    if (!(configs == rhs.configs))
      return false;
    if (!(nodeId == rhs.nodeId))
      return false;
    return true;
  }
  bool operator != (const TSetConfigurationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSetConfigurationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetConfigurationReq &a, TSetConfigurationReq &b);

std::ostream& operator<<(std::ostream& out, const TSetConfigurationReq& obj);


class TSetTTLReq : public virtual ::apache::thrift::TBase {
 public:

  TSetTTLReq(const TSetTTLReq&);
  TSetTTLReq& operator=(const TSetTTLReq&);
  TSetTTLReq() : TTL(0), isDataBase(0) {
  }

  virtual ~TSetTTLReq() noexcept;
  std::vector<std::string>  pathPattern;
  int64_t TTL;
  bool isDataBase;

  void __set_pathPattern(const std::vector<std::string> & val);

  void __set_TTL(const int64_t val);

  void __set_isDataBase(const bool val);

  bool operator == (const TSetTTLReq & rhs) const
  {
    if (!(pathPattern == rhs.pathPattern))
      return false;
    if (!(TTL == rhs.TTL))
      return false;
    if (!(isDataBase == rhs.isDataBase))
      return false;
    return true;
  }
  bool operator != (const TSetTTLReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSetTTLReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetTTLReq &a, TSetTTLReq &b);

std::ostream& operator<<(std::ostream& out, const TSetTTLReq& obj);


class TShowTTLReq : public virtual ::apache::thrift::TBase {
 public:

  TShowTTLReq(const TShowTTLReq&);
  TShowTTLReq& operator=(const TShowTTLReq&);
  TShowTTLReq() {
  }

  virtual ~TShowTTLReq() noexcept;
  std::vector<std::string>  pathPattern;

  void __set_pathPattern(const std::vector<std::string> & val);

  bool operator == (const TShowTTLReq & rhs) const
  {
    if (!(pathPattern == rhs.pathPattern))
      return false;
    return true;
  }
  bool operator != (const TShowTTLReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowTTLReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowTTLReq &a, TShowTTLReq &b);

std::ostream& operator<<(std::ostream& out, const TShowTTLReq& obj);


class TFile : public virtual ::apache::thrift::TBase {
 public:

  TFile(const TFile&);
  TFile& operator=(const TFile&);
  TFile() : fileName(), file() {
  }

  virtual ~TFile() noexcept;
  std::string fileName;
  std::string file;

  void __set_fileName(const std::string& val);

  void __set_file(const std::string& val);

  bool operator == (const TFile & rhs) const
  {
    if (!(fileName == rhs.fileName))
      return false;
    if (!(file == rhs.file))
      return false;
    return true;
  }
  bool operator != (const TFile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFile &a, TFile &b);

std::ostream& operator<<(std::ostream& out, const TFile& obj);


class TFilesResp : public virtual ::apache::thrift::TBase {
 public:

  TFilesResp(const TFilesResp&);
  TFilesResp& operator=(const TFilesResp&);
  TFilesResp() {
  }

  virtual ~TFilesResp() noexcept;
  TSStatus status;
  std::vector<TFile>  files;

  void __set_status(const TSStatus& val);

  void __set_files(const std::vector<TFile> & val);

  bool operator == (const TFilesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const TFilesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFilesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFilesResp &a, TFilesResp &b);

std::ostream& operator<<(std::ostream& out, const TFilesResp& obj);

typedef struct _TSpaceQuota__isset {
  _TSpaceQuota__isset() : diskSize(false), deviceNum(false), timeserieNum(false) {}
  bool diskSize :1;
  bool deviceNum :1;
  bool timeserieNum :1;
} _TSpaceQuota__isset;

class TSpaceQuota : public virtual ::apache::thrift::TBase {
 public:

  TSpaceQuota(const TSpaceQuota&);
  TSpaceQuota& operator=(const TSpaceQuota&);
  TSpaceQuota() : diskSize(0), deviceNum(0), timeserieNum(0) {
  }

  virtual ~TSpaceQuota() noexcept;
  int64_t diskSize;
  int64_t deviceNum;
  int64_t timeserieNum;

  _TSpaceQuota__isset __isset;

  void __set_diskSize(const int64_t val);

  void __set_deviceNum(const int64_t val);

  void __set_timeserieNum(const int64_t val);

  bool operator == (const TSpaceQuota & rhs) const
  {
    if (__isset.diskSize != rhs.__isset.diskSize)
      return false;
    else if (__isset.diskSize && !(diskSize == rhs.diskSize))
      return false;
    if (__isset.deviceNum != rhs.__isset.deviceNum)
      return false;
    else if (__isset.deviceNum && !(deviceNum == rhs.deviceNum))
      return false;
    if (__isset.timeserieNum != rhs.__isset.timeserieNum)
      return false;
    else if (__isset.timeserieNum && !(timeserieNum == rhs.timeserieNum))
      return false;
    return true;
  }
  bool operator != (const TSpaceQuota &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSpaceQuota & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSpaceQuota &a, TSpaceQuota &b);

std::ostream& operator<<(std::ostream& out, const TSpaceQuota& obj);


class TTimedQuota : public virtual ::apache::thrift::TBase {
 public:

  TTimedQuota(const TTimedQuota&);
  TTimedQuota& operator=(const TTimedQuota&);
  TTimedQuota() : timeUnit(0), softLimit(0) {
  }

  virtual ~TTimedQuota() noexcept;
  int64_t timeUnit;
  int64_t softLimit;

  void __set_timeUnit(const int64_t val);

  void __set_softLimit(const int64_t val);

  bool operator == (const TTimedQuota & rhs) const
  {
    if (!(timeUnit == rhs.timeUnit))
      return false;
    if (!(softLimit == rhs.softLimit))
      return false;
    return true;
  }
  bool operator != (const TTimedQuota &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTimedQuota & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTimedQuota &a, TTimedQuota &b);

std::ostream& operator<<(std::ostream& out, const TTimedQuota& obj);

typedef struct _TThrottleQuota__isset {
  _TThrottleQuota__isset() : throttleLimit(false), memLimit(false), cpuLimit(false) {}
  bool throttleLimit :1;
  bool memLimit :1;
  bool cpuLimit :1;
} _TThrottleQuota__isset;

class TThrottleQuota : public virtual ::apache::thrift::TBase {
 public:

  TThrottleQuota(const TThrottleQuota&);
  TThrottleQuota& operator=(const TThrottleQuota&);
  TThrottleQuota() : memLimit(0), cpuLimit(0) {
  }

  virtual ~TThrottleQuota() noexcept;
  std::map<ThrottleType::type, TTimedQuota>  throttleLimit;
  int64_t memLimit;
  int32_t cpuLimit;

  _TThrottleQuota__isset __isset;

  void __set_throttleLimit(const std::map<ThrottleType::type, TTimedQuota> & val);

  void __set_memLimit(const int64_t val);

  void __set_cpuLimit(const int32_t val);

  bool operator == (const TThrottleQuota & rhs) const
  {
    if (__isset.throttleLimit != rhs.__isset.throttleLimit)
      return false;
    else if (__isset.throttleLimit && !(throttleLimit == rhs.throttleLimit))
      return false;
    if (__isset.memLimit != rhs.__isset.memLimit)
      return false;
    else if (__isset.memLimit && !(memLimit == rhs.memLimit))
      return false;
    if (__isset.cpuLimit != rhs.__isset.cpuLimit)
      return false;
    else if (__isset.cpuLimit && !(cpuLimit == rhs.cpuLimit))
      return false;
    return true;
  }
  bool operator != (const TThrottleQuota &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TThrottleQuota & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TThrottleQuota &a, TThrottleQuota &b);

std::ostream& operator<<(std::ostream& out, const TThrottleQuota& obj);


class TSetSpaceQuotaReq : public virtual ::apache::thrift::TBase {
 public:

  TSetSpaceQuotaReq(const TSetSpaceQuotaReq&);
  TSetSpaceQuotaReq& operator=(const TSetSpaceQuotaReq&);
  TSetSpaceQuotaReq() {
  }

  virtual ~TSetSpaceQuotaReq() noexcept;
  std::vector<std::string>  database;
  TSpaceQuota spaceLimit;

  void __set_database(const std::vector<std::string> & val);

  void __set_spaceLimit(const TSpaceQuota& val);

  bool operator == (const TSetSpaceQuotaReq & rhs) const
  {
    if (!(database == rhs.database))
      return false;
    if (!(spaceLimit == rhs.spaceLimit))
      return false;
    return true;
  }
  bool operator != (const TSetSpaceQuotaReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSetSpaceQuotaReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetSpaceQuotaReq &a, TSetSpaceQuotaReq &b);

std::ostream& operator<<(std::ostream& out, const TSetSpaceQuotaReq& obj);


class TSetThrottleQuotaReq : public virtual ::apache::thrift::TBase {
 public:

  TSetThrottleQuotaReq(const TSetThrottleQuotaReq&);
  TSetThrottleQuotaReq& operator=(const TSetThrottleQuotaReq&);
  TSetThrottleQuotaReq() : userName() {
  }

  virtual ~TSetThrottleQuotaReq() noexcept;
  std::string userName;
  TThrottleQuota throttleQuota;

  void __set_userName(const std::string& val);

  void __set_throttleQuota(const TThrottleQuota& val);

  bool operator == (const TSetThrottleQuotaReq & rhs) const
  {
    if (!(userName == rhs.userName))
      return false;
    if (!(throttleQuota == rhs.throttleQuota))
      return false;
    return true;
  }
  bool operator != (const TSetThrottleQuotaReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSetThrottleQuotaReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetThrottleQuotaReq &a, TSetThrottleQuotaReq &b);

std::ostream& operator<<(std::ostream& out, const TSetThrottleQuotaReq& obj);


class TLicense : public virtual ::apache::thrift::TBase {
 public:

  TLicense(const TLicense&);
  TLicense& operator=(const TLicense&);
  TLicense() : licenseIssueTimestamp(0), expireTimestamp(0), dataNodeNumLimit(0), cpuCoreNumLimit(0), deviceNumLimit(0), sensorNumLimit(0), disconnectionFromActiveNodeTimeLimit(0), mlNodeNumLimit(0) {
  }

  virtual ~TLicense() noexcept;
  int64_t licenseIssueTimestamp;
  int64_t expireTimestamp;
  int16_t dataNodeNumLimit;
  int32_t cpuCoreNumLimit;
  int64_t deviceNumLimit;
  int64_t sensorNumLimit;
  int64_t disconnectionFromActiveNodeTimeLimit;
  int16_t mlNodeNumLimit;

  void __set_licenseIssueTimestamp(const int64_t val);

  void __set_expireTimestamp(const int64_t val);

  void __set_dataNodeNumLimit(const int16_t val);

  void __set_cpuCoreNumLimit(const int32_t val);

  void __set_deviceNumLimit(const int64_t val);

  void __set_sensorNumLimit(const int64_t val);

  void __set_disconnectionFromActiveNodeTimeLimit(const int64_t val);

  void __set_mlNodeNumLimit(const int16_t val);

  bool operator == (const TLicense & rhs) const
  {
    if (!(licenseIssueTimestamp == rhs.licenseIssueTimestamp))
      return false;
    if (!(expireTimestamp == rhs.expireTimestamp))
      return false;
    if (!(dataNodeNumLimit == rhs.dataNodeNumLimit))
      return false;
    if (!(cpuCoreNumLimit == rhs.cpuCoreNumLimit))
      return false;
    if (!(deviceNumLimit == rhs.deviceNumLimit))
      return false;
    if (!(sensorNumLimit == rhs.sensorNumLimit))
      return false;
    if (!(disconnectionFromActiveNodeTimeLimit == rhs.disconnectionFromActiveNodeTimeLimit))
      return false;
    if (!(mlNodeNumLimit == rhs.mlNodeNumLimit))
      return false;
    return true;
  }
  bool operator != (const TLicense &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLicense & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLicense &a, TLicense &b);

std::ostream& operator<<(std::ostream& out, const TLicense& obj);


class TLoadSample : public virtual ::apache::thrift::TBase {
 public:

  TLoadSample(const TLoadSample&);
  TLoadSample& operator=(const TLoadSample&);
  TLoadSample() : cpuUsageRate(0), memoryUsageRate(0), diskUsageRate(0), freeDiskSpace(0) {
  }

  virtual ~TLoadSample() noexcept;
  double cpuUsageRate;
  double memoryUsageRate;
  double diskUsageRate;
  double freeDiskSpace;

  void __set_cpuUsageRate(const double val);

  void __set_memoryUsageRate(const double val);

  void __set_diskUsageRate(const double val);

  void __set_freeDiskSpace(const double val);

  bool operator == (const TLoadSample & rhs) const
  {
    if (!(cpuUsageRate == rhs.cpuUsageRate))
      return false;
    if (!(memoryUsageRate == rhs.memoryUsageRate))
      return false;
    if (!(diskUsageRate == rhs.diskUsageRate))
      return false;
    if (!(freeDiskSpace == rhs.freeDiskSpace))
      return false;
    return true;
  }
  bool operator != (const TLoadSample &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLoadSample & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLoadSample &a, TLoadSample &b);

std::ostream& operator<<(std::ostream& out, const TLoadSample& obj);


class TServiceProvider : public virtual ::apache::thrift::TBase {
 public:

  TServiceProvider(const TServiceProvider&);
  TServiceProvider& operator=(const TServiceProvider&);
  TServiceProvider() : serviceType((TServiceType::type)0), nodeId(0) {
  }

  virtual ~TServiceProvider() noexcept;
  TEndPoint endPoint;
  /**
   * 
   * @see TServiceType
   */
  TServiceType::type serviceType;
  int32_t nodeId;

  void __set_endPoint(const TEndPoint& val);

  void __set_serviceType(const TServiceType::type val);

  void __set_nodeId(const int32_t val);

  bool operator == (const TServiceProvider & rhs) const
  {
    if (!(endPoint == rhs.endPoint))
      return false;
    if (!(serviceType == rhs.serviceType))
      return false;
    if (!(nodeId == rhs.nodeId))
      return false;
    return true;
  }
  bool operator != (const TServiceProvider &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TServiceProvider & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TServiceProvider &a, TServiceProvider &b);

std::ostream& operator<<(std::ostream& out, const TServiceProvider& obj);

typedef struct _TSender__isset {
  _TSender__isset() : dataNodeLocation(false), configNodeLocation(false) {}
  bool dataNodeLocation :1;
  bool configNodeLocation :1;
} _TSender__isset;

class TSender : public virtual ::apache::thrift::TBase {
 public:

  TSender(const TSender&);
  TSender& operator=(const TSender&);
  TSender() {
  }

  virtual ~TSender() noexcept;
  TDataNodeLocation dataNodeLocation;
  TConfigNodeLocation configNodeLocation;

  _TSender__isset __isset;

  void __set_dataNodeLocation(const TDataNodeLocation& val);

  void __set_configNodeLocation(const TConfigNodeLocation& val);

  bool operator == (const TSender & rhs) const
  {
    if (__isset.dataNodeLocation != rhs.__isset.dataNodeLocation)
      return false;
    else if (__isset.dataNodeLocation && !(dataNodeLocation == rhs.dataNodeLocation))
      return false;
    if (__isset.configNodeLocation != rhs.__isset.configNodeLocation)
      return false;
    else if (__isset.configNodeLocation && !(configNodeLocation == rhs.configNodeLocation))
      return false;
    return true;
  }
  bool operator != (const TSender &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSender & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSender &a, TSender &b);

std::ostream& operator<<(std::ostream& out, const TSender& obj);

typedef struct _TTestConnectionResult__isset {
  _TTestConnectionResult__isset() : reason(false) {}
  bool reason :1;
} _TTestConnectionResult__isset;

class TTestConnectionResult : public virtual ::apache::thrift::TBase {
 public:

  TTestConnectionResult(const TTestConnectionResult&);
  TTestConnectionResult& operator=(const TTestConnectionResult&);
  TTestConnectionResult() : success(0), reason() {
  }

  virtual ~TTestConnectionResult() noexcept;
  TServiceProvider serviceProvider;
  TSender sender;
  bool success;
  std::string reason;

  _TTestConnectionResult__isset __isset;

  void __set_serviceProvider(const TServiceProvider& val);

  void __set_sender(const TSender& val);

  void __set_success(const bool val);

  void __set_reason(const std::string& val);

  bool operator == (const TTestConnectionResult & rhs) const
  {
    if (!(serviceProvider == rhs.serviceProvider))
      return false;
    if (!(sender == rhs.sender))
      return false;
    if (!(success == rhs.success))
      return false;
    if (__isset.reason != rhs.__isset.reason)
      return false;
    else if (__isset.reason && !(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const TTestConnectionResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTestConnectionResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTestConnectionResult &a, TTestConnectionResult &b);

std::ostream& operator<<(std::ostream& out, const TTestConnectionResult& obj);


class TTestConnectionResp : public virtual ::apache::thrift::TBase {
 public:

  TTestConnectionResp(const TTestConnectionResp&);
  TTestConnectionResp& operator=(const TTestConnectionResp&);
  TTestConnectionResp() {
  }

  virtual ~TTestConnectionResp() noexcept;
  TSStatus status;
  std::vector<TTestConnectionResult>  resultList;

  void __set_status(const TSStatus& val);

  void __set_resultList(const std::vector<TTestConnectionResult> & val);

  bool operator == (const TTestConnectionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(resultList == rhs.resultList))
      return false;
    return true;
  }
  bool operator != (const TTestConnectionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTestConnectionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTestConnectionResp &a, TTestConnectionResp &b);

std::ostream& operator<<(std::ostream& out, const TTestConnectionResp& obj);

typedef struct _TNodeLocations__isset {
  _TNodeLocations__isset() : configNodeLocations(false), dataNodeLocations(false) {}
  bool configNodeLocations :1;
  bool dataNodeLocations :1;
} _TNodeLocations__isset;

class TNodeLocations : public virtual ::apache::thrift::TBase {
 public:

  TNodeLocations(const TNodeLocations&);
  TNodeLocations& operator=(const TNodeLocations&);
  TNodeLocations() {
  }

  virtual ~TNodeLocations() noexcept;
  std::vector<TConfigNodeLocation>  configNodeLocations;
  std::vector<TDataNodeLocation>  dataNodeLocations;

  _TNodeLocations__isset __isset;

  void __set_configNodeLocations(const std::vector<TConfigNodeLocation> & val);

  void __set_dataNodeLocations(const std::vector<TDataNodeLocation> & val);

  bool operator == (const TNodeLocations & rhs) const
  {
    if (__isset.configNodeLocations != rhs.__isset.configNodeLocations)
      return false;
    else if (__isset.configNodeLocations && !(configNodeLocations == rhs.configNodeLocations))
      return false;
    if (__isset.dataNodeLocations != rhs.__isset.dataNodeLocations)
      return false;
    else if (__isset.dataNodeLocations && !(dataNodeLocations == rhs.dataNodeLocations))
      return false;
    return true;
  }
  bool operator != (const TNodeLocations &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNodeLocations & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNodeLocations &a, TNodeLocations &b);

std::ostream& operator<<(std::ostream& out, const TNodeLocations& obj);


class TShowConfigurationTemplateResp : public virtual ::apache::thrift::TBase {
 public:

  TShowConfigurationTemplateResp(const TShowConfigurationTemplateResp&);
  TShowConfigurationTemplateResp& operator=(const TShowConfigurationTemplateResp&);
  TShowConfigurationTemplateResp() : content() {
  }

  virtual ~TShowConfigurationTemplateResp() noexcept;
  TSStatus status;
  std::string content;

  void __set_status(const TSStatus& val);

  void __set_content(const std::string& val);

  bool operator == (const TShowConfigurationTemplateResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(content == rhs.content))
      return false;
    return true;
  }
  bool operator != (const TShowConfigurationTemplateResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowConfigurationTemplateResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowConfigurationTemplateResp &a, TShowConfigurationTemplateResp &b);

std::ostream& operator<<(std::ostream& out, const TShowConfigurationTemplateResp& obj);


class TShowConfigurationResp : public virtual ::apache::thrift::TBase {
 public:

  TShowConfigurationResp(const TShowConfigurationResp&);
  TShowConfigurationResp& operator=(const TShowConfigurationResp&);
  TShowConfigurationResp() : content() {
  }

  virtual ~TShowConfigurationResp() noexcept;
  TSStatus status;
  std::string content;

  void __set_status(const TSStatus& val);

  void __set_content(const std::string& val);

  bool operator == (const TShowConfigurationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(content == rhs.content))
      return false;
    return true;
  }
  bool operator != (const TShowConfigurationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowConfigurationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowConfigurationResp &a, TShowConfigurationResp &b);

std::ostream& operator<<(std::ostream& out, const TShowConfigurationResp& obj);



#endif
